<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (14) on Fri Dec 09 08:59:11 CET 2022 -->
<title>AggregateOperation (hazelcast-jet-distribution 4.5.4 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-12-09">
<meta name="description" content="declaration: package: com.hazelcast.jet.aggregate, interface: AggregateOperation">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":6,"i1":18,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":18,"i9":6,"i10":18,"i11":1,"i12":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/AggregateOperation.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.jet.aggregate</a></div>
<h1 title="Interface AggregateOperation" class="title">Interface AggregateOperation&lt;A,&#8203;R&gt;</h1>
</div>
<div class="contentContainer">
<section class="description">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>A</code> - the type of the accumulator</dd>
<dd><code>R</code> - the type of the final result</dd>
</dl>
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io" class="externalLink">Serializable</a></code></dd>
</dl>
<dl>
<dt>All Known Subinterfaces:</dt>
<dd><code><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</code>, <code><a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;T0,&#8203;T1,&#8203;A,&#8203;R&gt;</code>, <code><a href="AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;T0,&#8203;T1,&#8203;T2,&#8203;A,&#8203;R&gt;</code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">AggregateOperation&lt;A,&#8203;R&gt;</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io" class="externalLink">Serializable</a></pre>
<div class="block">Contains primitives needed to compute an aggregated result of data
 processing. Check out <a href="AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a> to find the one
 you need and, if you don't find it there, construct one by using the
 <a href="#withCreate(com.hazelcast.function.SupplierEx)"><code>aggregate operation builder</code></a> and reading the
 description below.
 <p>
 Jet aggregates the data by updating a mutable container,
 called the <em>accumulator</em>, with the data from each stream item.
 It does this by applying the <a href="#accumulateFn(com.hazelcast.jet.datamodel.Tag)"><code>accumulate</code></a> primitive
 to the the accumulator and a given item. Jet provides some accumulator
 objects in the <a href="../accumulator/package-summary.html"><code>accumulator</code></a> package
 that you can reuse, and you can also write your own if needed. The
 accumulator must be serializable because Jet may need to send it to
 another member to be combined with other accumulators or store it in state
 snapshot.
 <p>
 After it processes all the items in a batch/window, Jet transforms the
 accumulator into the final result by applying the <a href="#finishFn()"><code>finish</code></a> primitive.
 <p>
 Since it is a distributed/parallel computation engine, Jet will create
 several independent processing units to perform the same aggregation,
 and it must combine their partial results before applying the <code>
 finish</code> primitive and emitting the final result. This is the role of the
 <a href="#combineFn()"><code>combine</code></a> primitive.
 <p>
 Finally, <code>AggregateOperation</code> also defines the <a href="#deductFn()"><code>deduct</code></a> primitive, which allows Jet to efficiently aggregate infinite
 stream data into a <em>sliding window</em> by evicting old data from the
 existing accumulator instead of building a new one from scratch each time
 the window slides forward. Providing a <code>deduct</code> primitive that makes
 the computation more efficient than rebuilding the accumulator from scratch
 isn't always possible. Therefore it is optional.
 <p>
 Depending on usage, the data items may come from one or more inbound
 streams, and the <code>AggregateOperation</code> must provide a separate
 <code>accumulate</code> primitive for each of them. If you are creating the
 aggregating pipeline stage using the <a href="../pipeline/StageWithKeyAndWindow.html#aggregateBuilder(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>builder object</code></a>, then you'll identify each contributing stream to the
 <code>AggregateOperation</code> using the <em>tags</em> you got from the
 builder.
 <p>
 If, on the other hand, you are calling one of the direct methods such
 as <a href="../pipeline/StageWithKeyAndWindow.html#aggregate2(com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation2)"><code>stage.aggregate2()</code></a>, then you'll deal with specializations of this interface
 such as <a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate"><code>AggregateOperation2</code></a> and you'll identify the input stages by
 their index; zero index corresponds to the stage you're calling the
 method on and the higher indices correspond to the stages you pass in as
 arguments.
 <p>
 This is a summary of all the primitives involved:
 <ol><li>
     <a href="#createFn()"><code>create</code></a> a new accumulator object
 </li><li>
     <a href="#accumulateFn(com.hazelcast.jet.datamodel.Tag)"><code>accumulate</code></a> the data of an item by mutating
     the accumulator
 </li><li>
     <a href="#combineFn()"><code>combine</code></a> the contents of the right-hand
     accumulator into the left-hand one, optional
 </li><li>
     <a href="#deductFn()"><code>deduct</code></a> the contents of the right-hand accumulator
     from the left-hand one (undo the effects of <code>combine</code>), optional
 </li><li>
     <a href="#exportFn()"><code>export</code></a>: calculate the result value from an
     accumulator while preserving the accumulator state for further
     accumulation. Used for aggregations with speculative results or for
     rolling aggregations
 </li><li>
     <a href="#finishFn()"><code>finish</code></a>: calculate the result value from an
     accumulator. After this conversion the accumulator will no longer be
     used, it's allowed, for example, to use the <code>identity()</code> function
 </li></ol>

 All the functions must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>3.0</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="tableTab" onclick="show(16);">Default Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#accumulateFn(int)">accumulateFn</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">A primitive that updates the accumulator state to account for a new
 item.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>default &lt;T&gt;&nbsp;<a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#accumulateFn(com.hazelcast.jet.datamodel.Tag)">accumulateFn</a></span>&#8203;(<a href="../datamodel/Tag.html" title="class in com.hazelcast.jet.datamodel">Tag</a>&lt;T&gt;&nbsp;tag)</code></th>
<td class="colLast">
<div class="block">A primitive that updates the accumulator state to account for a new
 item.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>&lt;R_NEW&gt;&nbsp;<a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;R_NEW&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#andThen(com.hazelcast.function.FunctionEx)">andThen</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>,&#8203;? extends R_NEW&gt;&nbsp;thenFn)</code></th>
<td class="colLast">
<div class="block">Returns a copy of this aggregate operation, but with the <code>export</code>
 and <code>finish</code> primitives composed with the supplied <code>thenFn</code>.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arity()">arity</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the number of contributing streams this operation is set up to
 handle.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineFn()">combineFn</a></span>()</code></th>
<td class="colLast">
<div class="block">A primitive that accepts two accumulators and updates the state of the
 left-hand one by combining it with the state of the right-hand one.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createFn()">createFn</a></span>()</code></th>
<td class="colLast">
<div class="block">A primitive that returns a new accumulator.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deductFn()">deductFn</a></span>()</code></th>
<td class="colLast">
<div class="block">A primitive that accepts two accumulators and updates the state of the
 left-hand one by deducting the state of the right-hand one from it.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? extends <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#exportFn()">exportFn</a></span>()</code></th>
<td class="colLast">
<div class="block">A primitive that transforms the accumulator into a result of the
 aggregation.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>default <a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? extends <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#finishFn()">finishFn</a></span>()</code></th>
<td class="colLast">
<div class="block">A primitive that transforms the accumulator into a result of the
 aggregation.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withAccumulateFns(com.hazelcast.function.BiConsumerEx...)">withAccumulateFns</a></span>&#8203;(<a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>...&nbsp;accumulateFns)</code></th>
<td class="colLast">
<div class="block">Returns a copy of this aggregate operation, but with all the <code>
 accumulate</code> primitives replaced with the ones supplied here.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>default &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withCombiningAccumulateFn(com.hazelcast.function.FunctionEx)">withCombiningAccumulateFn</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;T,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;&nbsp;getAccFn)</code></th>
<td class="colLast">
<div class="block">Returns a copy of this aggregate operation, but with the <code>
 accumulate</code> primitive replaced with one that expects to find accumulator
 objects in the input items and combines them all into a single
 accumulator of the same type.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static &lt;A&gt;&nbsp;<a href="AggregateOperationBuilder.html" title="class in com.hazelcast.jet.aggregate">AggregateOperationBuilder</a>&lt;A&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withCreate(com.hazelcast.function.SupplierEx)">withCreate</a></span>&#8203;(<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;A&gt;&nbsp;createFn)</code></th>
<td class="colLast">
<div class="block">Returns a builder object, initialized with the supplied <a href="#createFn()"><code>create</code></a> primitive, that can be used to construct the definition of an
 aggregate operation in a step-by-step manner.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withIdentityFinish()">withIdentityFinish</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a copy of this aggregate operation, but with the <code>finish</code>
 primitive replaced with the identity function.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="arity()">arity</a></h3>
<div class="memberSignature"><span class="returnType">int</span>&nbsp;<span class="memberName">arity</span>()</div>
<div class="block">Returns the number of contributing streams this operation is set up to
 handle. The index passed to <a href="#accumulateFn(int)"><code>accumulateFn(int)</code></a> must be less than
 this number.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="createFn()">createFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="returnType"><a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</span>&nbsp;<span class="memberName">createFn</span>()</div>
<div class="block">A primitive that returns a new accumulator. If the <code>deduct</code>
 primitive is defined, the accumulator object <strong>must</strong>
 properly implement <code>equals()</code>. See <a href="#deductFn()"><code>deductFn()</code></a> for an
 explanation.
 <p>
 The accumulator produced by the supplier must be serializable. For
 performance, you should prefer Hazelcast custom serialization.
 <p>
 The supplier must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="accumulateFn(com.hazelcast.jet.datamodel.Tag)">accumulateFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="typeParameters">&lt;T&gt;</span>&nbsp;<span class="returnType"><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super T&gt;</span>&nbsp;<span class="memberName">accumulateFn</span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
<a href="../datamodel/Tag.html" title="class in com.hazelcast.jet.datamodel">Tag</a>&lt;T&gt;&nbsp;tag)</span></div>
<div class="block">A primitive that updates the accumulator state to account for a new
 item. The tag argument identifies which of the contributing streams
 the returned function will handle. If asked for a tag that isn't
 registered with it, it will throw an exception.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="accumulateFn(int)">accumulateFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="typeParameters">&lt;T&gt;</span>&nbsp;<span class="returnType"><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super T&gt;</span>&nbsp;<span class="memberName">accumulateFn</span>&#8203;(<span class="arguments">int&nbsp;index)</span></div>
<div class="block">A primitive that updates the accumulator state to account for a new
 item. The argument identifies the index of the contributing stream
 the returned function will handle. If asked for an index that isn't
 registered with it, it will throw an exception.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="combineFn()">combineFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nullable</a>
</span><span class="returnType"><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</span>&nbsp;<span class="memberName">combineFn</span>()</div>
<div class="block">A primitive that accepts two accumulators and updates the state of the
 left-hand one by combining it with the state of the right-hand one.
 The right-hand accumulator remains unchanged. In some cases, such as
 for single-stage batch or tumbling window aggregation it is not needed
 and may be <code>null</code>.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="deductFn()">deductFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nullable</a>
</span><span class="returnType"><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</span>&nbsp;<span class="memberName">deductFn</span>()</div>
<div class="block">A primitive that accepts two accumulators and updates the state of the
 left-hand one by deducting the state of the right-hand one from it. The
 right-hand accumulator remains unchanged.
 <p>
 The effect of this primitive must be the opposite of <a href="#combineFn()"><code>combine</code></a> so that:
 <pre>
     combine(acc, x);
     deduct(acc, x);
 </pre>
 leaves <code>acc</code> in the same state as it was before the two
 operations.
 <p>
 This primitive is only used in sliding window aggregation and even in
 that case it is optional, but its presence may significantly reduce the
 computational cost. With it, the current sliding window can be obtained
 from the previous one by deducting the trailing frame and combining the
 leading frame; without it, each window must be recomputed from all its
 constituent frames. The finer the sliding step, the more pronounced the
 difference in computation effort will be.
 <p>
 If this method returns non-null, then <a href="#createFn()"><code>createFn()</code></a> <strong>must
 </strong> return an accumulator which properly implements <code>
 equals()</code>. After calling <code>deductFn</code>, Jet will use <code>equals()</code>
 to determine whether the accumulator is now "empty" (i.e., equal to a
 fresh instance), which signals that the current window contains no more
 items with the associated grouping key and the entry must be removed
 from the results. For example:
 <pre>
     acc = create();
     combine(acc, x);
     deduct(acc, x);
     assert acc.equals(create()) : "improper combine/deduct behavior";
 </pre>
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="exportFn()">exportFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="returnType"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? extends <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</span>&nbsp;<span class="memberName">exportFn</span>()</div>
<div class="block">A primitive that transforms the accumulator into a result of the
 aggregation. Unlike <a href="#finishFn()"><code>finish</code></a> primitive, this operation
 must not:
 <ul>
     <li>mutate the accumulator: it must remain ready to accumulate more
     items
     <li>the result must not share mutable data with the accumulator:
     accumulating more items to the accumulator must not change the result
 </ul>
 For example, when accumulating into an <code>ArrayList</code>, you must copy
 it before returning it. If the elements of the list are mutated, they
 must be copied as well.
 <p>
 The returned function must never return <code>null</code>. In other words,
 for any accumulator it must return a non-null exported value.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="finishFn()">finishFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;? extends <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</span>&nbsp;<span class="memberName">finishFn</span>()</div>
<div class="block">A primitive that transforms the accumulator into a result of the
 aggregation. This is a relaxed version of <a href="#exportFn()"><code>export</code></a>
 primitive: the accumulator is guaranteed to be no longer used after this
 operation. For example, when accumulating into an <code>ArrayList</code>, you
 can return the accumulator list directly without copying it.
 <p>
 The returned function must never return <code>null</code>. In other words,
 for any accumulator it must return a non-null finished value.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withAccumulateFns(com.hazelcast.function.BiConsumerEx...)">withAccumulateFns</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="returnType"><a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</span>&nbsp;<span class="memberName">withAccumulateFns</span>&#8203;(<span class="arguments"><a href="../../function/BiConsumerEx.html" title="interface in com.hazelcast.function">BiConsumerEx</a>...&nbsp;accumulateFns)</span></div>
<div class="block">Returns a copy of this aggregate operation, but with all the <code>
 accumulate</code> primitives replaced with the ones supplied here. The
 argument at position <code>i</code> replaces the primitive at index <code>
 i</code>, as returned by <a href="#accumulateFn(int)"><code>accumulateFn(int)</code></a>.
 <p>
 The functions must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withIdentityFinish()">withIdentityFinish</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="returnType"><a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;</span>&nbsp;<span class="memberName">withIdentityFinish</span>()</div>
<div class="block">Returns a copy of this aggregate operation, but with the <code>finish</code>
 primitive replaced with the identity function. It will return the
 accumulator object as-is. The returned aggregate operation does not
 support the <code>export</code> primitive.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withCombiningAccumulateFn(com.hazelcast.function.FunctionEx)">withCombiningAccumulateFn</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="typeParameters">&lt;T&gt;</span>&nbsp;<span class="returnType"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>&gt;</span>&nbsp;<span class="memberName">withCombiningAccumulateFn</span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;T,&#8203;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>&gt;&nbsp;getAccFn)</span></div>
<div class="block">Returns a copy of this aggregate operation, but with the <code>
 accumulate</code> primitive replaced with one that expects to find accumulator
 objects in the input items and combines them all into a single
 accumulator of the same type. It's used in the second aggregation stage
 of a two-stage aggregation setup. The first stage emits its accumulators
 to the second stage.
 <p>
 The function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of stream item</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>getAccFn</code> - the function that extracts the accumulator from the stream item</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="andThen(com.hazelcast.function.FunctionEx)">andThen</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="typeParameters">&lt;R_NEW&gt;</span>&nbsp;<span class="returnType"><a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;<a href="AggregateOperation.html" title="type parameter in AggregateOperation">A</a>,&#8203;R_NEW&gt;</span>&nbsp;<span class="memberName">andThen</span>&#8203;(<span class="arguments"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="AggregateOperation.html" title="type parameter in AggregateOperation">R</a>,&#8203;? extends R_NEW&gt;&nbsp;thenFn)</span></div>
<div class="block">Returns a copy of this aggregate operation, but with the <code>export</code>
 and <code>finish</code> primitives composed with the supplied <code>thenFn</code>.
 This replaces <code>exportFn</code> with <code>exportFn.andThen(thenFn)</code>,
 same for <code>finishFn</code>. The main use case is to transform the result
 of an existing (library-provided) aggregate operation.
 <p>
 The given function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R_NEW</code> - the type of the returned aggregate operation's result</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thenFn</code> - the function to apply to the results of <code>export</code> and <code>finish</code>
               primitives</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withCreate(com.hazelcast.function.SupplierEx)">withCreate</a></h3>
<div class="memberSignature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
</span><span class="modifiers">static</span>&nbsp;<span class="typeParameters">&lt;A&gt;</span>&nbsp;<span class="returnType"><a href="AggregateOperationBuilder.html" title="class in com.hazelcast.jet.aggregate">AggregateOperationBuilder</a>&lt;A&gt;</span>&nbsp;<span class="memberName">withCreate</span>&#8203;(<span class="arguments"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true" title="class or interface in javax.annotation" class="externalLink">@Nonnull</a>
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;A&gt;&nbsp;createFn)</span></div>
<div class="block">Returns a builder object, initialized with the supplied <a href="#createFn()"><code>create</code></a> primitive, that can be used to construct the definition of an
 aggregate operation in a step-by-step manner.
 <p>
 The same builder is used to construct both fixed- and variable-arity
 aggregate operations:
 <ul><li>
     For fixed arity use <a href="AggregateOperationBuilder.html#andAccumulate0(com.hazelcast.function.BiConsumerEx)"><code>andAccumulate0()</code></a>, optionally followed by <code>.andAccumulate1()</code>,
     <code>.andAccumulate2()</code>. The return type of these methods changes as the
     static types of the contributing streams are captured.
 </li><li>
     For variable arity use <a href="AggregateOperationBuilder.html#andAccumulate(com.hazelcast.jet.datamodel.Tag,com.hazelcast.function.BiConsumerEx)"><code>andAccumulate(tag)</code></a>.
 </li></ul>
 The <a href="AggregateOperationBuilder.Arity1.html#andExportFinish(com.hazelcast.function.FunctionEx)"><code>andExportFinish()</code></a> method returns the constructed aggregate operation.
 Its static type receives all the type parameters captured in the above
 method calls. For optimization purposes you may want to specify a <code>
 finish</code> primitive that is different from <code>export</code>, for example
 return the accumulator itself without copying. In that case you'll use
 <code>builder.andExport(exportFn).andFinish(finishFn)</code>.
 <p>
 The given function must be stateless and <a href="../core/Processor.html#isCooperative()">cooperative</a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>A</code> - the type of the accumulator</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>createFn</code> - the <code>create</code> primitive</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder object whose static type represents the fact that it
         has just the <code>create</code> primitive defined</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/AggregateOperation.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2022 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
