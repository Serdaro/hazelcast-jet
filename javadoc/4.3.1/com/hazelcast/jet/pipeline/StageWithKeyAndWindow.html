<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Wed Mar 10 10:12:22 CET 2021 -->
<title>StageWithKeyAndWindow (hazelcast-jet-distribution 4.3.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-03-10">
<meta name="description" content="declaration: package: com.hazelcast.jet.pipeline, interface: StageWithKeyAndWindow">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":18,"i2":6,"i3":18,"i4":6,"i5":18,"i6":18,"i7":18,"i8":6,"i9":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/StageWithKeyAndWindow.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.jet.pipeline</a></div>
<h1 title="Interface StageWithKeyAndWindow" class="title">Interface StageWithKeyAndWindow&lt;T,&#8203;K&gt;</h1>
</div>
<section class="description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - type of the key</dd>
</dl>
<hr>
<pre>public interface <span class="type-name-label">StageWithKeyAndWindow&lt;T,&#8203;K&gt;</span></pre>
<div class="block">Represents an intermediate step in the construction of a pipeline stage
 that performs a windowed group-and-aggregate operation. It captures the
 grouping key and the window definition, and offers the methods to finalize
 the construction by specifying the aggregate operation and any additional
 pipeline stages contributing their data to a co-group-and-aggregate stage.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>3.0</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="table-tab" onclick="show(16);">Default Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>&lt;R&gt;&nbsp;<a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregate(com.hazelcast.jet.aggregate.AggregateOperation1)">aggregate</a></span>&#8203;(<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Attaches a stage that performs the given group-and-aggregate operation.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>default &lt;T1,&#8203;
R0,&#8203;
R1&gt;&nbsp;<a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregate2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)">aggregate2</a></span>&#8203;(<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0,
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;?,&#8203;? extends R1&gt;&nbsp;aggrOp1)</code></th>
<td class="col-last">
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>&lt;T1,&#8203;
R&gt;&nbsp;<a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregate2(com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation2)">aggregate2</a></span>&#8203;(<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="../aggregate/AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? super T1,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>default &lt;T1,&#8203;
T2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;<br><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregate3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)">aggregate3</a></span>&#8203;(<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0,
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;?,&#8203;? extends R1&gt;&nbsp;aggrOp1,
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T2,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage2,
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;?,&#8203;? extends R2&gt;&nbsp;aggrOp2)</code></th>
<td class="col-last">
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>&lt;T1,&#8203;
T2,&#8203;
R&gt;&nbsp;<a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregate3(com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation3)">aggregate3</a></span>&#8203;(<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T2,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage2,
<a href="../aggregate/AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? super T1,&#8203;? super T2,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from this stage as well as <code>stage1</code> and <code>
 stage2</code> you supply.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>default <a href="WindowGroupAggregateBuilder1.html" title="class in com.hazelcast.jet.pipeline">WindowGroupAggregateBuilder1</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateBuilder()">aggregateBuilder</a></span>()</code></th>
<td class="col-last">
<div class="block">Offers a step-by-step API to build a pipeline stage that co-aggregates
 the data from several input stages.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>default &lt;R0&gt;&nbsp;<a href="WindowGroupAggregateBuilder.html" title="class in com.hazelcast.jet.pipeline">WindowGroupAggregateBuilder</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R0&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateBuilder(com.hazelcast.jet.aggregate.AggregateOperation1)">aggregateBuilder</a></span>&#8203;(<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0)</code></th>
<td class="col-last">
<div class="block">Offers a step-by-step API to build a pipeline stage that co-aggregates
 the data from several input stages.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>default <a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#distinct()">distinct</a></span>()</code></th>
<td class="col-last">
<div class="block">Attaches a stage that passes through just the items that are distinct
 within their window according to the grouping key (no two items emitted
 for a window map to the same key).</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#keyFn()">keyFn</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the function that extracts the grouping key from stream items.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code><a href="WindowDefinition.html" title="class in com.hazelcast.jet.pipeline">WindowDefinition</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#windowDefinition()">windowDefinition</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the definition of the window for the windowed aggregation
 operation that you are about to construct using this object.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="keyFn()">
<h3>keyFn</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;</span>&nbsp;<span class="member-name">keyFn</span>()</div>
<div class="block">Returns the function that extracts the grouping key from stream items.
 This function will be used in the aggregating stage you are about to
 construct using this object.</div>
</section>
</li>
<li>
<section class="detail" id="windowDefinition()">
<h3>windowDefinition</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="WindowDefinition.html" title="class in com.hazelcast.jet.pipeline">WindowDefinition</a></span>&nbsp;<span class="member-name">windowDefinition</span>()</div>
<div class="block">Returns the definition of the window for the windowed aggregation
 operation that you are about to construct using this object.</div>
</section>
</li>
<li>
<section class="detail" id="distinct()">
<h3>distinct</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>&gt;&gt;</span>&nbsp;<span class="member-name">distinct</span>()</div>
<div class="block">Attaches a stage that passes through just the items that are distinct
 within their window according to the grouping key (no two items emitted
 for a window map to the same key). There is no guarantee which one of
 the items with the same key will pass through.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the newly attached stage</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate(com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregate</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="type-parameters">&lt;R&gt;</span>&nbsp;<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</span>&nbsp;<span class="member-name">aggregate</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Attaches a stage that performs the given group-and-aggregate operation.
 It emits one key-value pair (in a <a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel"><code>KeyedWindowResult</code></a>) for each
 distinct key it observes in its input belonging to a given window. The
 value is the result of the aggregate operation across all the items with
 the given grouping key.
 <p>
 Sample usage:
 <pre><code>
 StreamStage&lt;KeyedWindowResult&lt;Long, Long&gt;&gt; aggregated = pageVisits
     .window(SlidingWindowDefinition.sliding(MINUTES.toMillis(1), SECONDS.toMillis(1)))
     .groupingKey(PageVisit::getUserId)
     .aggregate(AggregateOperations.counting());
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>R</code> - type of the aggregation result</dd>
<dt>Parameters:</dt>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
<dt>See Also:</dt>
<dd><a href="../aggregate/AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate2(com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation2)">
<h3>aggregate2</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="type-parameters">&lt;T1,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</span>&nbsp;<span class="member-name">aggregate2</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? super T1,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply. It
 emits one key-value pair (in a <a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel"><code>KeyedWindowResult</code></a>) for each
 distinct key it observes in the input belonging to a given window. The
 value is the result of the aggregate operation across all the items with
 the given grouping key.
 <p>
 Sample usage:
 <pre><code>
 StreamStage&lt;KeyedWindowResult&lt;Long, Tuple2&lt;Long, Long&gt;&gt;&gt; aggregated = pageVisits
     .window(SlidingWindowDefinition.sliding(MINUTES.toMillis(1), SECONDS.toMillis(1)))
     .groupingKey(PageVisit::getUserId)
     .aggregate2(
         addToCarts.groupingKey(AddToCart::getUserId),
         AggregateOperations.aggregateOperation2(
                 AggregateOperations.counting(),
                 AggregateOperations.counting())
     );
 </code></pre>
 This variant requires you to provide a two-input aggregate operation
 (refer to its <a href="../aggregate/AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">Javadoc</a> for a simple
 example). If you can express your logic in terms of two single-input
 aggregate operations, one for each input stream, then you should use
 <a href="#aggregate2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage0.aggregate2(aggrOp0, stage1, aggrOp1)</code></a> because it offers a simpler
 API and you can use the already defined single-input operations. Use
 this variant only when you have the need to implement an aggregate
 operation that combines the input streams into the same accumulator.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T1</code> - type of items in <code>stage1</code></dd>
<dd><code>R</code> - type of the aggregation result</dd>
<dt>Parameters:</dt>
<dd><code>stage1</code> - the other stage</dd>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
<dt>See Also:</dt>
<dd><a href="../aggregate/AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregate2</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="type-parameters">&lt;T1,&#8203;
R0,&#8203;
R1&gt;</span>
<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;&gt;</span>&nbsp;<span class="member-name">aggregate2</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;?,&#8203;? extends R1&gt;&nbsp;aggrOp1)</span></div>
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply. For
 each distinct grouping key it observes in the input belonging to a given
 window, it performs the supplied aggregate operation across all the
 items sharing that key. It performs the aggregation separately for each
 input stage: <code>aggrOp0</code> on this stage and <code>aggrOp1</code> on <code>
 stage1</code>. Once it has received all the items belonging to a window, it
 emits for each distinct key a <code>KeyedWindowResult(key, Tuple2(result0,
 result1))</code>.
 <p>
 Sample usage:
 <pre><code>
 StreamStage&lt;KeyedWindowResult&lt;Long, Tuple2&lt;Long, Long&gt;&gt;&gt; aggregated = pageVisits
     .window(SlidingWindowDefinition.sliding(MINUTES.toMillis(1), SECONDS.toMillis(1)))
     .groupingKey(PageVisit::getUserId)
     .aggregate2(
             AggregateOperations.counting(),
             addToCarts.groupingKey(AddToCart::getUserId),
             AggregateOperations.counting()
     );
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T1</code> - type of the items in the other stage</dd>
<dd><code>R0</code> - type of the aggregated result for this stage</dd>
<dd><code>R1</code> - type of the aggregated result for the other stage</dd>
<dt>Parameters:</dt>
<dd><code>aggrOp0</code> - aggregate operation to perform on this stage</dd>
<dd><code>stage1</code> - the other stage</dd>
<dd><code>aggrOp1</code> - aggregate operation to perform on the other stage</dd>
<dt>See Also:</dt>
<dd><a href="../aggregate/AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate3(com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation3)">
<h3>aggregate3</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="type-parameters">&lt;T1,&#8203;
T2,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R&gt;&gt;</span>&nbsp;<span class="member-name">aggregate3</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T2,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage2,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;? super T1,&#8203;? super T2,&#8203;?,&#8203;? extends R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from this stage as well as <code>stage1</code> and <code>
 stage2</code> you supply. For each distinct grouping key it observes in the
 input belonging to a given window, it performs the supplied aggregate
 operation across all the items sharing that key. Once it has received
 all the items belonging to a window, it emits for each distinct key a
 <code>KeyedWindowResult(key, Tuple3(result0, result1, result2))</code>.
 <p>
 Sample usage:
 StreamStage<KeyedWindowResult<Long, Tuple3<Long, Long, Long>>> aggregated = pageVisits
     .window(SlidingWindowDefinition.sliding(MINUTES.toMillis(1), SECONDS.toMillis(1)))
     .groupingKey(PageVisit::getUserId)
     .aggregate3(
         addToCarts.groupingKey(AddToCart::getUserId),
         payments.groupingKey(Payment::getUserId),
         AggregateOperations.aggregateOperation3(
             AggregateOperations.counting(),
             AggregateOperations.counting(),
             AggregateOperations.counting())
     );
 <pre><code>

 </code></pre>
 This variant requires you to provide a three-input aggregate operation
 (refer to its <a href="../aggregate/AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">Javadoc</a> for a simple
 example). If you can express your logic in terms of three single-input
 aggregate operations, one for each input stream, then you should use
 <a href="#aggregate3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage0.aggregate2(aggrOp0, stage1, aggrOp1, stage2, aggrOp2)</code></a> because it
 offers a simpler API and you can use the already defined single-input
 operations. Use this variant only when you have the need to implement an
 aggregate operation that combines the input streams into the same
 accumulator.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T1</code> - type of items in <code>stage1</code></dd>
<dd><code>T2</code> - type of items in <code>stage2</code></dd>
<dd><code>R</code> - type of the aggregation result</dd>
<dt>Parameters:</dt>
<dd><code>stage1</code> - the first additional stage</dd>
<dd><code>stage2</code> - the second additional stage</dd>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
<dt>See Also:</dt>
<dd><a href="../aggregate/AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregate3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.StreamStageWithKey,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregate3</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="type-parameters">&lt;T1,&#8203;
T2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;</span>
<span class="return-type"><a href="StreamStage.html" title="interface in com.hazelcast.jet.pipeline">StreamStage</a>&lt;<a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel">KeyedWindowResult</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;&gt;</span>&nbsp;<span class="member-name">aggregate3</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T1,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;?,&#8203;? extends R1&gt;&nbsp;aggrOp1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="StreamStageWithKey.html" title="interface in com.hazelcast.jet.pipeline">StreamStageWithKey</a>&lt;T2,&#8203;? extends <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;&nbsp;stage2,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;?,&#8203;? extends R2&gt;&nbsp;aggrOp2)</span></div>
<div class="block">Attaches a stage that performs the given cogroup-and-aggregate operation
 over the items from both this stage and <code>stage1</code> you supply. For
 each distinct grouping key it observes in the input belonging to a given
 window, it performs the supplied aggregate operation across all the
 items sharing that key. It performs the aggregation separately for each
 input stage: <code>aggrOp0</code> on this stage, <code>aggrOp1</code> on <code>
 stage1</code> and <code>aggrOp2</code> on <code>stage2</code>. Once it has received all
 the items, it calls the supplied <code>mapToOutputFn</code> with each key and
 the associated aggregation result to create the items to emit.
 <p>
 Sample usage:
 <pre><code>
 StreamStage&lt;KeyedWindowResult&lt;Long, Tuple3&lt;Long, Long, Long&gt;&gt;&gt; aggregated = pageVisits
     .window(SlidingWindowDefinition.sliding(MINUTES.toMillis(1), SECONDS.toMillis(1)))
     .groupingKey(PageVisit::getUserId)
     .aggregate3(
         AggregateOperations.counting(),
         addToCarts.groupingKey(AddToCart::getUserId),
         AggregateOperations.counting(),
         payments.groupingKey(Payment::getUserId),
         AggregateOperations.counting()
     );
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T1</code> - type of the items in <code>stage1</code></dd>
<dd><code>T2</code> - type of the items in <code>stage2</code></dd>
<dd><code>R0</code> - type of the aggregated result for this stage</dd>
<dd><code>R1</code> - type of the aggregated result for <code>stage1</code></dd>
<dd><code>R2</code> - type of the aggregated result for <code>stage2</code></dd>
<dt>Parameters:</dt>
<dd><code>aggrOp0</code> - aggregate operation to perform on this stage</dd>
<dd><code>stage1</code> - the first additional stage</dd>
<dd><code>aggrOp1</code> - aggregate operation to perform on <code>stage1</code></dd>
<dd><code>stage2</code> - the second additional stage</dd>
<dd><code>aggrOp2</code> - aggregate operation to perform on <code>stage2</code></dd>
<dt>See Also:</dt>
<dd><a href="../aggregate/AggregateOperations.html" title="class in com.hazelcast.jet.aggregate"><code>AggregateOperations</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateBuilder(com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregateBuilder</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="type-parameters">&lt;R0&gt;</span>&nbsp;<span class="return-type"><a href="WindowGroupAggregateBuilder.html" title="class in com.hazelcast.jet.pipeline">WindowGroupAggregateBuilder</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>,&#8203;R0&gt;</span>&nbsp;<span class="member-name">aggregateBuilder</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../aggregate/AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super <a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;?,&#8203;? extends R0&gt;&nbsp;aggrOp0)</span></div>
<div class="block">Offers a step-by-step API to build a pipeline stage that co-aggregates
 the data from several input stages. The current stage will be already
 registered with the builder you get. You supply an aggregate operation
 for each input stage and in the output you get the individual
 aggregation results as <a href="../datamodel/KeyedWindowResult.html" title="class in com.hazelcast.jet.datamodel"><code>KeyedWindowResult(key,
 itemsByTag)</code></a>. Use the tag you get from <a href="AggregateBuilder.html#add(com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>builder.add(stageN, aggrOpN)</code></a> to retrieve the aggregated result for that
 stage. Use <a href="AggregateBuilder.html#tag0()"><code>builder.tag0()</code></a> as the tag of
 this stage.
 <p>
 This builder is mainly intended to build a co-aggregation of four or
 more contributing stages. For up to three stages, prefer the direct
 <code>stage.aggregateN(...)</code> calls because they offer more static type
 safety.
 <p>
 This example reads from three stream sources that produce <code>
 Map.Entry&lt;String, Long&gt;</code>. It groups by entry key, defines a 1-second
 sliding window and then counts the items in stage-0, sums those in
 stage-1 and takes the average of those in stage-2:
 <pre><code>
 Pipeline p = Pipeline.create();
 StreamStageWithKey&lt;Entry&lt;String, Long&gt;, String&gt; stage0 =
         p.readFrom(source0).withNativeTimestamps(0L)
          .groupingKey(Entry::getKey);
 StreamStageWithKey&lt;Entry&lt;String, Long&gt;, String&gt; stage1 =
         p.readFrom(source1).withNativeTimestamps(0L)
          .groupingKey(Entry::getKey);
 StreamStageWithKey&lt;Entry&lt;String, Long&gt;, String&gt; stage2 =
         p.readFrom(source2).withNativeTimestamps(0L)
          .groupingKey(Entry::getKey);
 WindowGroupAggregateBuilder&lt;String, Long&gt; b = stage0
         .window(sliding(1000, 10))
         .aggregateBuilder(AggregateOperations.counting());
 Tag&lt;Long&gt; tag0 = b.tag0();
 Tag&lt;Long&gt; tag1 = b.add(stage1,
         AggregateOperations.summingLong(Entry::getValue));
 Tag&lt;Double&gt; tag2 = b.add(stage2,
         AggregateOperations.averagingLong(Entry::getValue));
 StreamStage&lt;KeyedWindowResult&lt;String, ItemsByTag&gt;&gt; aggregated = b.build();
 aggregated.map(e -&gt; String.format(
         "Key %s, count of stage0: %d, sum of stage1: %d, average of stage2: %f",
         e.getKey(),
         e.getValue().get(tag0), e.getValue().get(tag1), e.getValue().get(tag2))
 );
</code></pre></div>
</section>
</li>
<li>
<section class="detail" id="aggregateBuilder()">
<h3>aggregateBuilder</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="WindowGroupAggregateBuilder1.html" title="class in com.hazelcast.jet.pipeline">WindowGroupAggregateBuilder1</a>&lt;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">T</a>,&#8203;<a href="StageWithKeyAndWindow.html" title="type parameter in StageWithKeyAndWindow">K</a>&gt;</span>&nbsp;<span class="member-name">aggregateBuilder</span>()</div>
<div class="block">Offers a step-by-step API to build a pipeline stage that co-aggregates
 the data from several input stages. This stage will be already
 registered with the builder you get.
 <p>
 This builder requires you to provide a multi-input aggregate operation.
 If you can express your logic in terms of single-input aggregate
 operations, one for each input stream, then you should use <a href="#aggregateBuilder(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage0.aggregateBuilder(aggrOp0)</code></a>
 because it offers a simpler API. Use this builder only when you have the
 need to implement an aggregate operation that combines all the input
 streams into the same accumulator.
 <p>
 This builder is mainly intended to build a co-aggregation of four or
 more contributing stages. For up to three stages, prefer the direct
 <code>stage.aggregateN(...)</code> calls because they offer more static type
 safety.
 <p>
 To add the other stages, call <a href="WindowGroupAggregateBuilder1.html#add(com.hazelcast.jet.pipeline.StreamStageWithKey)"><code>builder.add(stage)</code></a>. Collect all the tags returned from <code>add()</code>
 and use them when building the aggregate operation. Retrieve the tag of
 the first stage (from which you obtained this builder) by calling <a href="WindowGroupAggregateBuilder1.html#tag0()"><code>builder.tag0()</code></a>.
 <p>
 This example takes three streams of <code>Map.Entry&lt;String, Long&gt;</code>,
 specifies a 1-second sliding window and, for each string key, counts
 the distinct <code>Long</code> values across all input streams:
 <pre><code>
 Pipeline p = Pipeline.create();

 StreamStageWithGrouping&lt;Entry&lt;String, Long&gt;, String&gt; stage0 =
         p.readFrom(source0).groupingKey(Entry::getKey);
 StreamStageWithGrouping&lt;Entry&lt;String, Long&gt;, String&gt; stage1 =
         p.readFrom(source1).groupingKey(Entry::getKey);
 StreamStageWithGrouping&lt;Entry&lt;String, Long&gt;, String&gt; stage2 =
         p.readFrom(source2).groupingKey(Entry::getKey);

 WindowGroupAggregateBuilder1&lt;Entry&lt;String, Long&gt;, String&gt; b = stage0
         .window(sliding(1000, 10))
         .aggregateBuilder();
 Tag&lt;Entry&lt;String, Long&gt;&gt; tag0 = b.tag0();
 Tag&lt;Entry&lt;String, Long&gt;&gt; tag1 = b.add(stage1);
 Tag&lt;Entry&lt;String, Long&gt;&gt; tag2 = b.add(stage2);
 StreamStage&lt;KeyedWindowResult&lt;String, Integer&gt;&gt; aggregated = b.build(AggregateOperation
         .withCreate(HashSet&lt;Long&gt;::new)
         .andAccumulate(tag0, (acc, item) -&gt; acc.add(item.getValue()))
         .andAccumulate(tag1, (acc, item) -&gt; acc.add(item.getValue()))
         .andAccumulate(tag2, (acc, item) -&gt; acc.add(item.getValue()))
         .andCombine(HashSet::addAll)
         .andFinish(HashSet::size));
 </code></pre></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/StageWithKeyAndWindow.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
