<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Wed Mar 10 10:12:22 CET 2021 -->
<title>AggregateOperations (hazelcast-jet-distribution 4.3.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-03-10">
<meta name="description" content="declaration: package: com.hazelcast.jet.aggregate, class: AggregateOperations">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/AggregateOperations.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.jet.aggregate</a></div>
<h1 title="Class AggregateOperations" class="title">Class AggregateOperations</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.hazelcast.jet.aggregate.AggregateOperations</div>
</div>
<section class="description">
<hr>
<pre>public final class <span class="type-name-label">AggregateOperations</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></pre>
<div class="block">Utility class with factory methods for several useful aggregate
 operations. See the Javadoc on <a href="AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate"><code>AggregateOperation</code></a>. You can
 also create your own aggregate operation using the <a href="AggregateOperation.html#withCreate(com.hazelcast.function.SupplierEx)"><code>builder object</code></a>.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>3.0</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>static &lt;T0,&#8203;
T1,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1&gt;<br><a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;T0,&#8203;T1,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">aggregateOperation2</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1)</code></th>
<td class="col-last">
<div class="block">Convenience for <a href="#aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>aggregateOperation2(aggrOp0, aggrOp1, finishFn)</code></a> that outputs a
 <code>Tuple2(result0, result1)</code>.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>static &lt;T0,&#8203;
A0,&#8203;
R0,&#8203;
T1,&#8203;
A1,&#8203;
R1,&#8203;
R&gt;<br><a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;T0,&#8203;T1,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)">aggregateOperation2</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super R0,&#8203;? super R1,&#8203;? extends R&gt;&nbsp;exportFinishFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that is a composite of two independent
 aggregate operations, each one accepting its own input.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>static &lt;T0,&#8203;
T1,&#8203;
T2,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;<br><a href="AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;T0,&#8203;T1,&#8203;T2,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">aggregateOperation3</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2)</code></th>
<td class="col-last">
<div class="block">Convenience for <a href="#aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)"><code>aggregateOperation3(aggrOp0, aggrOp1, aggrOp2, finishFn)</code></a> that outputs a
 <code>Tuple3(result0, result1, result2)</code>.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>static &lt;T0,&#8203;
T1,&#8203;
T2,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2,&#8203;
R&gt;<br><a href="AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;T0,&#8203;T1,&#8203;T2,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)">aggregateOperation3</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2,
<a href="../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super R0,&#8203;? super R1,&#8203;? super R2,&#8203;? extends R&gt;&nbsp;exportFinishFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that is a composite of three independent
 aggregate operations, each one accepting its own input.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>static &lt;T,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1,&#8203;
R&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)">allOf</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super R0,&#8203;? super R1,&#8203;? extends R&gt;&nbsp;exportFinishFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that is a composite of two aggregate
 operations.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>static &lt;T,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">allOf</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2)</code></th>
<td class="col-last">
<div class="block">Convenience for <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)"><code>allOf(AggregateOperation1, AggregateOperation1,
 AggregateOperation1, TriFunction)</code></a> wrapping the three results in a
 <a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel"><code>Tuple3</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>static &lt;T,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2,&#8203;
R&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)">allOf</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2,
<a href="../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super R0,&#8203;? super R1,&#8203;? super R2,&#8203;? extends R&gt;&nbsp;exportFinishFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that is a composite of three aggregate
 operations.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>static &lt;T,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">allOf</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;R0&gt;&nbsp;op1,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;R1&gt;&nbsp;op2)</code></th>
<td class="col-last">
<div class="block">Convenience for <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>allOf(AggregateOperation1, AggregateOperation1,
 BiFunctionEx)</code></a> wrapping the two results in a <a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel"><code>Tuple2</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AllOfAggregationBuilder.html" title="class in com.hazelcast.jet.aggregate">AllOfAggregationBuilder</a>&lt;T&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allOfBuilder()">allOfBuilder</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns a builder object that helps you create a composite of multiple
 aggregate operations.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongDoubleAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongDoubleAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#averagingDouble(com.hazelcast.function.ToDoubleFunctionEx)">averagingDouble</a></span>&#8203;(<a href="../../function/ToDoubleFunctionEx.html" title="interface in com.hazelcast.function">ToDoubleFunctionEx</a>&lt;? super T&gt;&nbsp;getDoubleValueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that finds the arithmetic mean (aka.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongLongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongLongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#averagingLong(com.hazelcast.function.ToLongFunctionEx)">averagingLong</a></span>&#8203;(<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;getLongValueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that finds the arithmetic mean (aka.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link">PriorityQueue</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#bottomN(int,com.hazelcast.function.ComparatorEx)">bottomN</a></span>&#8203;(int&nbsp;n,
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that finds the bottom <code>n</code> items
 according to the given <a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function"><code>comparator</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>static <a href="CoAggregateOperationBuilder.html" title="class in com.hazelcast.jet.aggregate">CoAggregateOperationBuilder</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#coAggregateOperationBuilder()">coAggregateOperationBuilder</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns a builder object that offers a step-by-step fluent API to create
 an aggregate operation that accepts multiple inputs.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>static <a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#concatenating()">concatenating</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them into a single string.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>static <a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#concatenating(java.lang.CharSequence)">concatenating</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;delimiter)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them, separated by the given <code>delimiter</code>, into a single string.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>static <a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#concatenating(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">concatenating</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;delimiter,
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;prefix,
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;suffix)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them, separated by the given <code>delimiter</code>, into a single string.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#counting()">counting</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that counts the items it observes.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>static &lt;T,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filtering(com.hazelcast.function.PredicateEx,com.hazelcast.jet.aggregate.AggregateOperation1)">filtering</a></span>&#8203;(<a href="../../function/PredicateEx.html" title="interface in com.hazelcast.function">PredicateEx</a>&lt;? super T&gt;&nbsp;filterFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</code></th>
<td class="col-last">
<div class="block">Adapts an aggregate operation so that it accumulates only the items
 passing the <code>filterFn</code> and ignores others.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>static &lt;T,&#8203;
U,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#flatMapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">flatMapping</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends <a href="../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;? extends U&gt;&gt;&nbsp;flatMapFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super U,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</code></th>
<td class="col-last">
<div class="block">Adapts an aggregate operation that takes items of type <code>U</code> to one
 that takes items of type <code>T</code>, by exploding each <code>T</code> into a
 sequence of <code>U</code>s and then accumulating all of them.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>static &lt;T,&#8203;
K&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#groupingBy(com.hazelcast.function.FunctionEx)">groupingBy</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> where the key is the result of applying <code>keyFn</code>
 and the value is a list of the items with that key.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
R,&#8203;
A,&#8203;
M extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;
R&gt;&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;A&gt;,&#8203;M&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.function.SupplierEx,com.hazelcast.jet.aggregate.AggregateOperation1)">groupingBy</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;M&gt;&nbsp;createMapFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;R&gt;&nbsp;downstream)</code></th>
<td class="col-last">
<div class="block">Returns an <code>AggregateOperation1</code> that accumulates the items into a
 <code>Map</code> (as obtained from <code>createMapFn</code>) where the key is the
 result of applying <code>keyFn</code> and the value is the result of
 applying the downstream aggregate operation to the items with that key.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;A&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;R&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">groupingBy</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;R&gt;&nbsp;downstream)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> where the key is the result of applying <code>keyFn</code>
 and the value is the result of applying the downstream aggregate
 operation to the items with that key.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LinTrendAccumulator.html" title="class in com.hazelcast.jet.accumulator">LinTrendAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#linearTrend(com.hazelcast.function.ToLongFunctionEx,com.hazelcast.function.ToLongFunctionEx)">linearTrend</a></span>&#8203;(<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;T&gt;&nbsp;getXFn,
<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;T&gt;&nbsp;getYFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that computes a linear trend over the
 items.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>static &lt;T,&#8203;
U,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">mapping</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;mapFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super U,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</code></th>
<td class="col-last">
<div class="block">Adapts an aggregate operation that takes items of type <code>U</code> to one
 that takes items of type <code>T</code>, by applying the given mapping
 function to each item.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#maxBy(com.hazelcast.function.ComparatorEx)">maxBy</a></span>&#8203;(<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that computes the greatest item according
 to the given <code>comparator</code>.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#minBy(com.hazelcast.function.ComparatorEx)">minBy</a></span>&#8203;(<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that computes the least item according to
 the given <code>comparator</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#pickAny()">pickAny</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation whose result is an arbitrary item it
 observed, or <code>null</code> if it observed no items.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>static &lt;T,&#8203;
A&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;A&gt;,&#8203;A&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#reducing(A,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.BinaryOperatorEx)">reducing</a></span>&#8203;(A&nbsp;emptyAccValue,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends A&gt;&nbsp;toAccValueFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;A&gt;&nbsp;combineAccValuesFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;A&gt;&nbsp;deductAccValueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that constructs the result through the
 process of <em>immutable reduction</em>:
 
     The initial accumulated value is <code>emptyAccValue</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" title="class or interface in java.util" class="external-link">ArrayList</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#sorting(com.hazelcast.function.ComparatorEx)">sorting</a></span>&#8203;(<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates all input items into an
 <code>ArrayList</code> and sorts it with the given comparator.</div>
</td>
</tr>
<tr class="row-color" id="i29">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/DoubleAccumulator.html" title="class in com.hazelcast.jet.accumulator">DoubleAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#summingDouble(com.hazelcast.function.ToDoubleFunctionEx)">summingDouble</a></span>&#8203;(<a href="../../function/ToDoubleFunctionEx.html" title="interface in com.hazelcast.function">ToDoubleFunctionEx</a>&lt;? super T&gt;&nbsp;getDoubleValueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that computes the sum of the <code>
 double</code> values it obtains by applying <code>getDoubleValueFn</code> to each
 item.</div>
</td>
</tr>
<tr class="alt-color" id="i30">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#summingLong(com.hazelcast.function.ToLongFunctionEx)">summingLong</a></span>&#8203;(<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;getLongValueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that computes the sum of the <code>long</code>
 values it obtains by applying <code>getLongValueFn</code> to each item.</div>
</td>
</tr>
<tr class="row-color" id="i31">
<td class="col-first"><code>static &lt;T,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="../../aggregation/Aggregator.html" title="interface in com.hazelcast.aggregation">Aggregator</a>&lt;T,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toAggregator(com.hazelcast.jet.aggregate.AggregateOperation1)">toAggregator</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Adapts this aggregate operation to be used for <a href="../../map/IMap.html#aggregate(com.hazelcast.aggregation.Aggregator)"><code>IMap.aggregate(Aggregator)</code></a>
 calls.</div>
</td>
</tr>
<tr class="alt-color" id="i32">
<td class="col-first"><code>static &lt;T,&#8203;
C extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" title="class or interface in java.util" class="external-link">Collection</a>&lt;T&gt;&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;C,&#8203;C&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toCollection(com.hazelcast.function.SupplierEx)">toCollection</a></span>&#8203;(<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;C&gt;&nbsp;createCollectionFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 Collection</code>.</div>
</td>
</tr>
<tr class="row-color" id="i33">
<td class="col-first"><code>static &lt;T,&#8203;
A,&#8203;
R&gt;&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" title="class or interface in java.util.stream" class="external-link">Collector</a>&lt;T,&#8203;A,&#8203;R&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toCollector(com.hazelcast.jet.aggregate.AggregateOperation1)">toCollector</a></span>&#8203;(<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Adapts this aggregate operation to a collector which can be passed to
 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect(java.util.stream.Collector)" title="class or interface in java.util.stream" class="external-link"><code>Stream.collect(Collector)</code></a>.</div>
</td>
</tr>
<tr class="alt-color" id="i34">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toList()">toList</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into an <code>
 ArrayList</code>.</div>
</td>
</tr>
<tr class="row-color" id="i35">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
U&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)">toMap</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 HashMap</code> whose keys and values are the result of applying the provided
 mapping functions.</div>
</td>
</tr>
<tr class="alt-color" id="i36">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
U&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx)">toMap</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;U&gt;&nbsp;mergeFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> whose keys and values are the result of applying
 the provided mapping functions.</div>
</td>
</tr>
<tr class="row-color" id="i37">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
U,&#8203;
M extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;
U&gt;&gt;<br><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;M,&#8203;M&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.SupplierEx)">toMap</a></span>&#8203;(<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;U&gt;&nbsp;mergeFn,
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;M&gt;&nbsp;createMapFn)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates elements into a
 user-supplied <code>Map</code> instance.</div>
</td>
</tr>
<tr class="alt-color" id="i38">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link">PriorityQueue</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#topN(int,com.hazelcast.function.ComparatorEx)">topN</a></span>&#8203;(int&nbsp;n,
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that finds the top <code>n</code> items
 according to the given <a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function"><code>comparator</code></a>.</div>
</td>
</tr>
<tr class="row-color" id="i39">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;T&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toSet()">toSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 HashSet</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="counting()">
<h3>counting</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="member-name">counting</span>()</div>
<div class="block">Returns an aggregate operation that counts the items it observes. The
 result is of type <code>long</code>.
 <p>
 This sample takes a stream of words and finds the number of occurrences
 of each word in it:
 <pre><code>
 BatchStage&lt;String&gt; words = pipeline.readFrom(wordSource);
 BatchStage&lt;Entry&lt;String, Long&gt;&gt; wordFrequencies =
     words.groupingKey(wholeItem()).aggregate(counting());
 </code></pre></div>
</section>
</li>
<li>
<section class="detail" id="summingLong(com.hazelcast.function.ToLongFunctionEx)">
<h3>summingLong</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="member-name">summingLong</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;getLongValueFn)</span></div>
<div class="block">Returns an aggregate operation that computes the sum of the <code>long</code>
 values it obtains by applying <code>getLongValueFn</code> to each item.
 <p>
 This sample takes a stream of lines of text and outputs a single <code>
 long</code> number telling how many words there were in the stream:
 <pre><code>
 BatchStage&lt;String&gt; linesOfText = pipeline.readFrom(textSource);
 BatchStage&lt;Long&gt; numberOfWordsInText =
         linesOfText
                 .map(line -&gt; line.split("\\W+"))
                 .aggregate(summingLong(wordsInLine -&gt; wordsInLine.length));
 </code></pre>

 <strong>Note:</strong> if the sum exceeds <code>Long.MAX_VALUE</code>, the job
 will fail with an <code>ArithmeticException</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>getLongValueFn</code> - function that extracts the <code>long</code> values you want to sum</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="summingDouble(com.hazelcast.function.ToDoubleFunctionEx)">
<h3>summingDouble</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/DoubleAccumulator.html" title="class in com.hazelcast.jet.accumulator">DoubleAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</span>&nbsp;<span class="member-name">summingDouble</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToDoubleFunctionEx.html" title="interface in com.hazelcast.function">ToDoubleFunctionEx</a>&lt;? super T&gt;&nbsp;getDoubleValueFn)</span></div>
<div class="block">Returns an aggregate operation that computes the sum of the <code>
 double</code> values it obtains by applying <code>getDoubleValueFn</code> to each
 item.
 <p>
 This sample takes a stream of purchase events and outputs a single
 <code>double</code> value that tells the total sum of money spent in
 them:
 <pre><code>
 BatchStage&lt;Purchase&gt; purchases = pipeline.readFrom(purchaseSource);
 BatchStage&lt;Double&gt; purchaseVolume =
         purchases.aggregate(summingDouble(Purchase::amount));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>getDoubleValueFn</code> - function that extracts the <code>double</code> values you want to sum</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="minBy(com.hazelcast.function.ComparatorEx)">
<h3>minBy</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</span>&nbsp;<span class="member-name">minBy</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns an aggregate operation that computes the least item according to
 the given <code>comparator</code>.
 <p>
 This sample takes a stream of people and finds the youngest person in it:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Person&gt; youngestPerson =
         people.aggregate(minBy(ComparatorEx.comparing(Person::age)));
 </code></pre>
 <strong>NOTE:</strong> if this aggregate operation doesn't observe any
 items, its result will be <code>null</code>. Since the non-keyed <a href="../pipeline/BatchStage.html#aggregate(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>BatchStage.aggregate(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, ?, ? extends R&gt;)</code></a> emits just the naked aggregation result, and since
 a <code>null</code> cannot travel through a Jet pipeline, you will not get
 any output in that case.
 <p>
 If several items tie for the least one, this aggregate operation will
 choose any one to return and may choose a different one each time.
 <p>
 <em>Implementation note:</em> this aggregate operation does not
 implement the <a href="AggregateOperation.html#deductFn()"><code>deduct</code></a> primitive.
 This has performance implications for <a href="https://jet-start.sh/docs/architecture/sliding-window">sliding
 window aggregation</a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>comparator</code> - comparator to compare the items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="maxBy(com.hazelcast.function.ComparatorEx)">
<h3>maxBy</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</span>&nbsp;<span class="member-name">maxBy</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns an aggregate operation that computes the greatest item according
 to the given <code>comparator</code>.
 <p>
 This sample takes a stream of people and finds the oldest person in it:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Person&gt; oldestPerson =
         people.aggregate(maxBy(ComparatorEx.comparing(Person::age)));
 </code></pre>
 <strong>NOTE:</strong> if this aggregate operation doesn't observe any
 items, its result will be <code>null</code>. Since the non-keyed <a href="../pipeline/BatchStage.html#aggregate(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>BatchStage.aggregate(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, ?, ? extends R&gt;)</code></a> emits just the naked aggregation result, and since
 a <code>null</code> cannot travel through a Jet pipeline, you will not get
 any output in that case.
 <p>
 If several items tie for the greatest one, this aggregate operation will
 choose any one to return and may choose a different one each time.
 <p>
 <em>Implementation note:</em> this aggregate operation does not
 implement the <a href="AggregateOperation.html#deductFn()"><code>deduct</code></a> primitive.
 This has performance implications for <a href="https://jet-start.sh/docs/architecture/sliding-window">sliding
 window aggregation</a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>comparator</code> - comparator to compare the items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="topN(int,com.hazelcast.function.ComparatorEx)">
<h3>topN</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link">PriorityQueue</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</span>&nbsp;<span class="member-name">topN</span>&#8203;(<span class="parameters">int&nbsp;n,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns an aggregate operation that finds the top <code>n</code> items
 according to the given <a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function"><code>comparator</code></a>. It outputs a
 sorted list with the top item in the first position.
 <p>
 This sample takes a stream of people and finds ten oldest persons in it:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;List&lt;Person&gt;&gt; oldestDudes =
         people.aggregate(topN(10, ComparatorEx.comparing(Person::age)));
 </code></pre>
 <em>Implementation note:</em> this aggregate operation does not
 implement the <a href="AggregateOperation.html#deductFn()"><code>deduct</code></a> primitive.
 This has performance implications for <a href="https://jet-start.sh/docs/architecture/sliding-window">sliding
 window aggregation</a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>n</code> - number of top items to find</dd>
<dd><code>comparator</code> - compares the items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bottomN(int,com.hazelcast.function.ComparatorEx)">
<h3>bottomN</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link">PriorityQueue</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</span>&nbsp;<span class="member-name">bottomN</span>&#8203;(<span class="parameters">int&nbsp;n,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns an aggregate operation that finds the bottom <code>n</code> items
 according to the given <a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function"><code>comparator</code></a>. It outputs a
 sorted list with the bottom item in the first position.
 <p>
 This sample takes a stream of people and finds ten youngest persons in
 it:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;List&lt;Person&gt;&gt; youngestDudes =
         people.aggregate(bottomN(10, ComparatorEx.comparing(Person::age)));
 </code></pre>
 <em>Implementation note:</em> this aggregate operation does not
 implement the <a href="AggregateOperation.html#deductFn()"><code>deduct</code></a> primitive.
 This has performance implications for <a href="https://jet-start.sh/docs/architecture/sliding-window">sliding
 window aggregation</a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>n</code> - number of bottom items to find</dd>
<dd><code>comparator</code> - compares the items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="averagingLong(com.hazelcast.function.ToLongFunctionEx)">
<h3>averagingLong</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongLongAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongLongAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</span>&nbsp;<span class="member-name">averagingLong</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;getLongValueFn)</span></div>
<div class="block">Returns an aggregate operation that finds the arithmetic mean (aka.
 average) of the <code>long</code> values it obtains by applying <code>
 getLongValueFn</code> to each item. It outputs the result as a <code>double</code>.
 <p>
 This sample takes a stream of people and finds their mean age:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Double&gt; meanAge = people.aggregate(averagingLong(Person::age));
 </code></pre>
 <p>
 If the aggregate operation does not observe any input, its result is
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#NaN" title="class or interface in java.lang" class="external-link"><code>NaN</code></a>.
 <p>
 <strong>NOTE:</strong> this operation accumulates the sum and the
 count as separate <code>long</code> variables and combines them at the end
 into the mean value. If either of these variables exceeds <code>
 Long.MAX_VALUE</code>, the job will fail with an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ArithmeticException.html" title="class or interface in java.lang" class="external-link"><code>ArithmeticException</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>getLongValueFn</code> - function that extracts the <code>long</code> value from the item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="averagingDouble(com.hazelcast.function.ToDoubleFunctionEx)">
<h3>averagingDouble</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LongDoubleAccumulator.html" title="class in com.hazelcast.jet.accumulator">LongDoubleAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</span>&nbsp;<span class="member-name">averagingDouble</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToDoubleFunctionEx.html" title="interface in com.hazelcast.function">ToDoubleFunctionEx</a>&lt;? super T&gt;&nbsp;getDoubleValueFn)</span></div>
<div class="block">Returns an aggregate operation that finds the arithmetic mean (aka.
 average) of the <code>double</code> values it obtains by applying <code>
 getDoubleValueFn</code> to each item. It outputs the result as a <code>double</code>.
 <p>
 This sample takes a stream of people and finds their mean age:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Double&gt; meanAge = people.aggregate(averagingDouble(Person::age));
 </code></pre>
 <p>
 If the aggregate operation does not observe any input, its result is
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#NaN" title="class or interface in java.lang" class="external-link"><code>NaN</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>getDoubleValueFn</code> - function that extracts the <code>double</code> value from the item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="linearTrend(com.hazelcast.function.ToLongFunctionEx,com.hazelcast.function.ToLongFunctionEx)">
<h3>linearTrend</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/LinTrendAccumulator.html" title="class in com.hazelcast.jet.accumulator">LinTrendAccumulator</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" title="class or interface in java.lang" class="external-link">Double</a>&gt;</span>&nbsp;<span class="member-name">linearTrend</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;T&gt;&nbsp;getXFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;T&gt;&nbsp;getYFn)</span></div>
<div class="block">Returns an aggregate operation that computes a linear trend over the
 items. It will produce a <code>double</code>-valued coefficient that
 approximates the rate of change of <code>y</code> as a function of <code>x</code>,
 where <code>x</code> and <code>y</code> are <code>long</code> quantities obtained
 by applying the two provided functions to each item.
 <p>
 This sample takes an infinite stream of trade events and outputs the
 current rate of price change using a sliding window:
 <pre><code>
 StreamStage&lt;Trade&gt; trades = pipeline
         .readFrom(tradeSource)
         .withTimestamps(Trade::getTimestamp, SECONDS.toMillis(1));
 StreamStage&lt;WindowResult&lt;Double&gt;&gt; priceTrend = trades
     .window(WindowDefinition.sliding(MINUTES.toMillis(5), SECONDS.toMillis(1)))
     .aggregate(linearTrend(Trade::getTimestamp, Trade::getPrice));
 </code></pre>
 With the trade price given in cents and the timestamp in milliseconds,
 the output will be in cents per millisecond. Make sure you apply a
 scaling factor if you want another, more natural unit of measure.
 <p>
 If this aggregate operation does not observe any input, its result is
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#NaN" title="class or interface in java.lang" class="external-link"><code>NaN</code></a>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dt>Parameters:</dt>
<dd><code>getXFn</code> - a function to extract <strong>x</strong> from the input</dd>
<dd><code>getYFn</code> - a function to extract <strong>y</strong> from the input</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="concatenating()">
<h3>concatenating</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</span>&nbsp;<span class="member-name">concatenating</span>()</div>
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them into a single string.
 <p>
 This sample outputs a string that you get by reading down the first
 column of the input text:
 <pre><code>
 BatchStage&lt;String&gt; linesOfText = pipeline.readFrom(textSource);
 BatchStage&lt;String&gt; lineStarters = linesOfText
         .map(line -&gt; line.charAt(0))
         .map(Object::toString)
         .aggregate(concatenating());
 </code></pre></div>
</section>
</li>
<li>
<section class="detail" id="concatenating(java.lang.CharSequence)">
<h3>concatenating</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</span>&nbsp;<span class="member-name">concatenating</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;delimiter)</span></div>
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them, separated by the given <code>delimiter</code>, into a single string.
 <p>
 This sample outputs a single line of text that contains all the
 upper-cased and title-cased words of the input text:
 <pre><code>
 BatchStage&lt;String&gt; linesOfText = pipeline.readFrom(textSource);
 BatchStage&lt;String&gt; upcaseWords = linesOfText
         .map(line -&gt; line.split("\\W+"))
         .flatMap(Traversers::traverseArray)
         .filter(word -&gt; word.matches("\\p{Lu}.*"))
         .aggregate(concatenating(" "));
 </code></pre></div>
</section>
</li>
<li>
<section class="detail" id="concatenating(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">
<h3>concatenating</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;</span>&nbsp;<span class="member-name">concatenating</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;delimiter,
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;prefix,
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;suffix)</span></div>
<div class="block">Returns an aggregate operation that takes string items and concatenates
 them, separated by the given <code>delimiter</code>, into a single string.
 The resulting string will start with the given <code>prefix</code> and end
 with the given <code>suffix</code>.
 <p>
 This sample outputs a single item, a JSON array of all the upper-cased
 and title-cased words of the input text:
 <pre><code>
 BatchStage&lt;String&gt; linesOfText = pipeline.readFrom(textSource);
 BatchStage&lt;String&gt; upcaseWords = linesOfText
         .map(line -&gt; line.split("\\W+"))
         .flatMap(Traversers::traverseArray)
         .filter(word -&gt; word.matches("\\p{Lu}.*"))
         .aggregate(concatenating("['", "', '", "']"));
 </code></pre></div>
</section>
</li>
<li>
<section class="detail" id="mapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>mapping</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
U,&#8203;
A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</span>&nbsp;<span class="member-name">mapping</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;mapFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super U,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</span></div>
<div class="block">Adapts an aggregate operation that takes items of type <code>U</code> to one
 that takes items of type <code>T</code>, by applying the given mapping
 function to each item. Normally you should just apply the mapping in a
 stage before the aggregation, but this adapter is useful when
 simultaneously performing several aggregate operations using <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>allOf(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A0, ? extends R0&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A1, ? extends R1&gt;, com.hazelcast.function.BiFunctionEx&lt;? super R0, ? super R1, ? extends R&gt;)</code></a>.
 <p>
 In addition to mapping, you can apply filtering as well by returning
 <code>null</code> for an item you want filtered out.
 <p>
 This sample takes a stream of people and builds two sorted lists from
 it, one with all the names and one with all the surnames:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Tuple2&lt;List&lt;String&gt;, List&lt;String&gt;&gt;&gt; sortedNames =
     people.aggregate(allOf(
         mapping(Person::getFirstName, sorting(ComparatorEx.naturalOrder())),
         mapping(Person::getLastName, sorting(ComparatorEx.naturalOrder()))));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>U</code> - input type of the downstream aggregate operation</dd>
<dd><code>A</code> - downstream operation's accumulator type</dd>
<dd><code>R</code> - downstream operation's result type</dd>
<dt>Parameters:</dt>
<dd><code>mapFn</code> - the function to apply to the input items</dd>
<dd><code>downstream</code> - the downstream aggregate operation</dd>
<dt>See Also:</dt>
<dd><a href="#filtering(com.hazelcast.function.PredicateEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>filtering(com.hazelcast.function.PredicateEx&lt;? super T&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A, ? extends R&gt;)</code></a>, 
<a href="#flatMapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>flatMapping(com.hazelcast.function.FunctionEx&lt;? super T, ? extends com.hazelcast.jet.Traverser&lt;? extends U&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super U, A, ? extends R&gt;)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filtering(com.hazelcast.function.PredicateEx,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>filtering</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</span>&nbsp;<span class="member-name">filtering</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/PredicateEx.html" title="interface in com.hazelcast.function">PredicateEx</a>&lt;? super T&gt;&nbsp;filterFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</span></div>
<div class="block">Adapts an aggregate operation so that it accumulates only the items
 passing the <code>filterFn</code> and ignores others. Normally you should
 just apply the filter in a stage before the aggregation, but this
 adapter is useful when simultaneously performing several aggregate
 operations using <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>allOf(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A0, ? extends R0&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A1, ? extends R1&gt;, com.hazelcast.function.BiFunctionEx&lt;? super R0, ? super R1, ? extends R&gt;)</code></a>.
 <p>
 This sample takes a stream of people and outputs two numbers, the
 average height of kids and grown-ups:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Tuple2&lt;Double, Double&gt;&gt; avgHeightByAge = people.aggregate(allOf(
     filtering((Person p) -&gt; p.getAge() &lt; 18, averagingLong(Person::getHeight)),
     filtering((Person p) -&gt; p.getAge() &gt;= 18, averagingLong(Person::getHeight))
 ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>A</code> - downstream operation's accumulator type</dd>
<dd><code>R</code> - downstream operation's result type</dd>
<dt>Parameters:</dt>
<dd><code>filterFn</code> - the filtering function</dd>
<dd><code>downstream</code> - the downstream aggregate operation</dd>
<dt>Since:</dt>
<dd>3.1</dd>
<dt>See Also:</dt>
<dd><a href="#mapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>mapping(com.hazelcast.function.FunctionEx&lt;? super T, ? extends U&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super U, A, ? extends R&gt;)</code></a>, 
<a href="#flatMapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>flatMapping(com.hazelcast.function.FunctionEx&lt;? super T, ? extends com.hazelcast.jet.Traverser&lt;? extends U&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super U, A, ? extends R&gt;)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>flatMapping</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
U,&#8203;
A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;A,&#8203;R&gt;</span>&nbsp;<span class="member-name">flatMapping</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends <a href="../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;? extends U&gt;&gt;&nbsp;flatMapFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super U,&#8203;A,&#8203;? extends R&gt;&nbsp;downstream)</span></div>
<div class="block">Adapts an aggregate operation that takes items of type <code>U</code> to one
 that takes items of type <code>T</code>, by exploding each <code>T</code> into a
 sequence of <code>U</code>s and then accumulating all of them. Normally you
 should just apply the flat-mapping in a stage before the aggregation,
 but this adapter is useful when simultaneously performing several
 aggregate operations using <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>allOf(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A0, ? extends R0&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A1, ? extends R1&gt;, com.hazelcast.function.BiFunctionEx&lt;? super R0, ? super R1, ? extends R&gt;)</code></a>.
 <p>
 The traverser your function returns must be non-null and
 <em>null-terminated</em>.
 <p>
 This sample takes a stream of people and outputs two numbers, the mean
 age of all the people and the mean age of people listed as someone's
 kid:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 people.aggregate(allOf(
     averagingLong(Person::getAge),
     flatMapping((Person p) -&gt; traverseIterable(p.getChildren()),
             averagingLong(Person::getAge))
 ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>U</code> - input type of the downstream aggregate operation</dd>
<dd><code>A</code> - downstream operation's accumulator type</dd>
<dd><code>R</code> - downstream operation's result type</dd>
<dt>Parameters:</dt>
<dd><code>flatMapFn</code> - the flat-mapping function to apply</dd>
<dd><code>downstream</code> - the downstream aggregate operation</dd>
<dt>Since:</dt>
<dd>3.1</dd>
<dt>See Also:</dt>
<dd><a href="#mapping(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>mapping(com.hazelcast.function.FunctionEx&lt;? super T, ? extends U&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super U, A, ? extends R&gt;)</code></a>, 
<a href="#filtering(com.hazelcast.function.PredicateEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>filtering(com.hazelcast.function.PredicateEx&lt;? super T&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, A, ? extends R&gt;)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toCollection(com.hazelcast.function.SupplierEx)">
<h3>toCollection</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
C extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" title="class or interface in java.util" class="external-link">Collection</a>&lt;T&gt;&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;C,&#8203;C&gt;</span>&nbsp;<span class="member-name">toCollection</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;C&gt;&nbsp;createCollectionFn)</span></div>
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 Collection</code>. It creates empty, mutable collections as needed by calling
 the provided <code>createCollectionFn</code>.
 <p>
 This sample takes a stream of words and outputs a single sorted set of
 all the long words (above 5 letters):
 <pre><code>
 BatchStage&lt;String&gt; words = pipeline.readFrom(wordSource);
 BatchStage&lt;SortedSet&lt;String&gt;&gt; sortedLongWords = words
         .filter(w -&gt; w.length() &gt; 5)
         .aggregate(toCollection(TreeSet::new));
 </code></pre>
 <strong>Note:</strong> if you use a collection that preserves the
 insertion order, keep in mind that Jet doesn't aggregate the items in
 any specified order.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>C</code> - the type of the collection</dd>
<dt>Parameters:</dt>
<dd><code>createCollectionFn</code> - a <code>Supplier</code> of empty, mutable <code>Collection</code>s</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toList()">
<h3>toList</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</span>&nbsp;<span class="member-name">toList</span>()</div>
<div class="block">Returns an aggregate operation that accumulates the items into an <code>
 ArrayList</code>.
 <p>
 This sample takes a stream of words and outputs a single list of all the
 long words (above 5 letters):
 <pre><code>
 BatchStage&lt;String&gt; words = pipeline.readFrom(wordSource);
 BatchStage&lt;List&lt;String&gt;&gt; longWords = words
         .filter(w -&gt; w.length() &gt; 5)
         .aggregate(toList());
 </code></pre>
 <strong>Note:</strong> accumulating all the data into an in-memory list
 shouldn't be your first choice in designing a pipeline. Consider
 draining the result stream to a sink.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toSet()">
<h3>toSet</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;T&gt;&gt;</span>&nbsp;<span class="member-name">toSet</span>()</div>
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 HashSet</code>.
 <p>
 This sample takes a stream of people and outputs a single set of all the
 distinct cities they live in:
 <pre><code>
 pipeline.readFrom(personSource)
         .map(Person::getCity)
         .aggregate(toSet());
 </code></pre>
 <strong>Note:</strong> accumulating all the data into an in-memory set
 shouldn't be your first choice in designing a pipeline. Consider
 draining the result stream to a sink.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)">
<h3>toMap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
U&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;&gt;</span>&nbsp;<span class="member-name">toMap</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn)</span></div>
<div class="block">Returns an aggregate operation that accumulates the items into a <code>
 HashMap</code> whose keys and values are the result of applying the provided
 mapping functions.
 <p>
 This aggregate operation does not tolerate duplicate keys and will throw
 an <code>IllegalStateException</code> if it detects them. If your data
 contains duplicates, use <a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx)"><code>toMap(keyFn, valueFn, mergeFn)</code></a>.
 <p>
 The following sample takes a stream of sensor readings and outputs a
 single map {sensor ID -> reading}:
 <pre><code>
 BatchStage&lt;Map&lt;String, Double&gt;&gt; readings = pipeline
         .readFrom(sensorData)
         .aggregate(toMap(
                 SensorReading::getSensorId,
                 SensorReading::getValue));
 </code></pre>
 <strong>Note:</strong> accumulating all the data into an in-memory map
 shouldn't be your first choice in designing a pipeline. Consider
 draining the stream to a sink.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - type of the key</dd>
<dd><code>U</code> - type of the value</dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from the input item</dd>
<dd><code>valueFn</code> - a function to extract the value from the input item</dd>
<dt>See Also:</dt>
<dd><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx)"><code>toMap(FunctionEx, FunctionEx, BinaryOperatorEx)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.SupplierEx)"><code>toMap(FunctionEx, FunctionEx, BinaryOperatorEx, SupplierEx)</code></a>, 
<a href="#groupingBy(com.hazelcast.function.FunctionEx)"><code>groupingBy(FunctionEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx)">
<h3>toMap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
U&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;U&gt;&gt;</span>&nbsp;<span class="member-name">toMap</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;U&gt;&nbsp;mergeFn)</span></div>
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> whose keys and values are the result of applying
 the provided mapping functions.
 <p>
 This aggregate operation resolves duplicate keys by applying <code>
 mergeFn</code> to the conflicting values. <code>mergeFn</code> will act upon the
 values after <code>valueFn</code> has already been applied.
 <p>
 The following sample takes a stream of sensor readings and outputs a
 single map {sensor ID -> reading}. Multiple readings from the same
 sensor get summed up:
 <pre><code>
 BatchStage&lt;Map&lt;String, Double&gt;&gt; readings = pipeline
         .readFrom(sensorData)
         .aggregate(toMap(
                 SensorReading::getSensorId,
                 SensorReading::getValue,
                 Double::sum));
 </code></pre>
 <strong>Note:</strong> accumulating all the data into an in-memory map
 shouldn't be your first choice in designing a pipeline. Consider
 draining the stream to a sink.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - the type of key</dd>
<dd><code>U</code> - the output type of the value mapping function</dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from input item</dd>
<dd><code>valueFn</code> - a function to extract value from input item</dd>
<dd><code>mergeFn</code> - the function used to resolve collisions between values associated
                with the same key, will be passed to <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge(K,V,java.util.function.BiFunction)" title="class or interface in java.util" class="external-link"><code>Map.merge(Object, Object,
                java.util.function.BiFunction)</code></a></dd>
<dt>See Also:</dt>
<dd><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)"><code>toMap(FunctionEx, FunctionEx)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.SupplierEx)"><code>toMap(FunctionEx, FunctionEx, BinaryOperatorEx, SupplierEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.SupplierEx)">
<h3>toMap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
U,&#8203;
M extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;
U&gt;&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;M,&#8203;M&gt;</span>&nbsp;<span class="member-name">toMap</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends U&gt;&nbsp;valueFn,
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;U&gt;&nbsp;mergeFn,
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;M&gt;&nbsp;createMapFn)</span></div>
<div class="block">Returns an aggregate operation that accumulates elements into a
 user-supplied <code>Map</code> instance. The keys and values are the result
 of applying the provided mapping functions to the input elements.
 <p>
 This aggregate operation resolves duplicate keys by applying <code>
 mergeFn</code> to the conflicting values. <code>mergeFn</code> will act upon the
 values after <code>valueFn</code> has already been applied.
 <p>
 The following sample takes a stream of sensor readings and outputs a
 single <code>ObjectToLongHashMap</code> of {sensor ID -> reading}. Multiple
 readings from the same sensor get summed up:
 <pre><code>
 BatchStage&lt;Map&lt;String, Long&gt;&gt; readings = pipeline
         .readFrom(sensorData)
         .aggregate(toMap(
                 SensorReading::getSensorId,
                 SensorReading::getValue,
                 Long::sum,
                 ObjectToLongHashMap::new));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - the output type of the key mapping function</dd>
<dd><code>U</code> - the output type of the value mapping function</dd>
<dd><code>M</code> - the type of the resulting <code>Map</code></dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from input item</dd>
<dd><code>valueFn</code> - a function to extract value from input item</dd>
<dd><code>mergeFn</code> - a merge function, used to resolve collisions between
                      values associated with the same key, as supplied
                      to <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge(K,V,java.util.function.BiFunction)" title="class or interface in java.util" class="external-link"><code>Map.merge(Object, Object,
                      java.util.function.BiFunction)</code></a></dd>
<dd><code>createMapFn</code> - a function which returns a new, empty <code>Map</code> into
                    which the results will be inserted</dd>
<dt>See Also:</dt>
<dd><a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)"><code>toMap(FunctionEx, FunctionEx)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx)"><code>toMap(FunctionEx, FunctionEx, BinaryOperatorEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="groupingBy(com.hazelcast.function.FunctionEx)">
<h3>groupingBy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;&gt;</span>&nbsp;<span class="member-name">groupingBy</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn)</span></div>
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> where the key is the result of applying <code>keyFn</code>
 and the value is a list of the items with that key.
 <p>
 This operation is primarily useful when you need a cascaded group-by
 where you further classify the members of each group by a secondary key.
 <p>
 This sample takes a stream of persons and classifies them first by
 country and then by gender. It outputs a stream of map entries where the
 key is the country and the value is a map from gender to the list of
 people of that gender from that country:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(personSource);
 BatchStage&lt;Entry&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt;&gt; byCountryAndGender =
         people.groupingKey(Person::getCountry)
               .aggregate(groupingBy(Person::getGender));
     </code>
 }</pre>

 This aggregate operation has a similar effect to the dedicated <a href="../pipeline/GeneralStage.html#groupingKey(com.hazelcast.function.FunctionEx)"><code>groupingKey()</code></a> pipeline transform
 so you may wonder why not use it in all cases, not just cascaded
 grouping. To see the difference, check out these two snippets:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(personSource);

 // Snippet 1
 BatchStage&lt;Entry&lt;String, List&lt;Person&gt;&gt;&gt; byCountry1 =
         people.groupingKey(Person::getCountry)
               .aggregate(toList());

 // Snippet 2
 BatchStage&lt;Map&lt;String, List&lt;Person&gt;&gt;&gt; byCountry2 =
         people.aggregate(groupingBy(Person::getCountry));
 </code></pre>

 Notice that snippet 1 outputs a <em>stream of map entries</em> whereas
 snippet 2 outputs a <em>single map</em>. To produce the single map,
 Jet must do all the work on a single thread and hold all the data on a
 single cluster member, so you lose the advantage of distributed
 computation. By contrast, snippet 2 allows Jet to partition the input by
 the grouping key and split the work across the cluster. This is why you
 should prefer a <code>groupingKey</code> stage if you have just one level of
 grouping.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - the output type of the key mapping function</dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from input item</dd>
<dt>See Also:</dt>
<dd><a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>groupingBy(FunctionEx, AggregateOperation1)</code></a>, 
<a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.function.SupplierEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>groupingBy(FunctionEx, SupplierEx, AggregateOperation1)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)"><code>toMap(FunctionEx, FunctionEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>groupingBy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
A,&#8203;
R&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;A&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;R&gt;&gt;</span>&nbsp;<span class="member-name">groupingBy</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;R&gt;&nbsp;downstream)</span></div>
<div class="block">Returns an aggregate operation that accumulates the items into a
 <code>HashMap</code> where the key is the result of applying <code>keyFn</code>
 and the value is the result of applying the downstream aggregate
 operation to the items with that key.
 <p>
 This operation is primarily useful when you need a cascaded group-by
 where you further classify the members of each group by a secondary key.
 For the difference between this operation and the <a href="../pipeline/GeneralStage.html#groupingKey(com.hazelcast.function.FunctionEx)"><code>groupingKey()</code></a> pipeline transform,
 see the documentation on <a href="#groupingBy(com.hazelcast.function.FunctionEx)"><code>groupingBy(keyFn)</code></a>.
 <p>
 This sample takes a stream of people, classifies them by country and
 gender, and reports the number of people in each category:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(personSource);
 BatchStage&lt;Entry&lt;String, Map&lt;String, Long&gt;&gt;&gt; countByCountryAndGender =
         people.groupingKey(Person::getCountry)
               .aggregate(groupingBy(Person::getGender, counting()));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - the output type of the key mapping function</dd>
<dd><code>R</code> - the type of the downstream aggregation result</dd>
<dd><code>A</code> - downstream aggregation's accumulator type</dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from input item</dd>
<dd><code>downstream</code> - the downstream aggregate operation</dd>
<dt>See Also:</dt>
<dd><a href="#groupingBy(com.hazelcast.function.FunctionEx)"><code>groupingBy(FunctionEx)</code></a>, 
<a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.function.SupplierEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>groupingBy(FunctionEx, SupplierEx, AggregateOperation1)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)"><code>toMap(FunctionEx, FunctionEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.function.SupplierEx,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>groupingBy</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
R,&#8203;
A,&#8203;
M extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;
R&gt;&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" title="class or interface in java.util" class="external-link">Map</a>&lt;K,&#8203;A&gt;,&#8203;M&gt;</span>&nbsp;<span class="member-name">groupingBy</span>&#8203;(<span class="parameters"><a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;M&gt;&nbsp;createMapFn,
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;R&gt;&nbsp;downstream)</span></div>
<div class="block">Returns an <code>AggregateOperation1</code> that accumulates the items into a
 <code>Map</code> (as obtained from <code>createMapFn</code>) where the key is the
 result of applying <code>keyFn</code> and the value is the result of
 applying the downstream aggregate operation to the items with that key.
 <p>
 This operation is primarily useful when you need a cascaded group-by
 where you further classify the members of each group by a secondary key.
 For the difference between this operation and the <a href="../pipeline/GeneralStage.html#groupingKey(com.hazelcast.function.FunctionEx)"><code>groupingKey()</code></a> pipeline transform,
 see the documentation on <a href="#groupingBy(com.hazelcast.function.FunctionEx)"><code>groupingBy(keyFn)</code></a>.
 <p>
 The following sample takes a stream of people, classifies them by country
 and gender, and reports the number of people in each category. It uses
 the <code>EnumMap</code> to optimize memory usage:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(personSource);
 BatchStage&lt;Entry&lt;String, Map&lt;Gender, Long&gt;&gt;&gt; countByCountryAndGender =
         people.groupingKey(Person::getCountry)
               .aggregate(groupingBy(
                       Person::getGender,
                       () -&gt; new EnumMap&lt;&gt;(Gender.class),
                       counting()));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - the output type of the key mapping function</dd>
<dd><code>R</code> - the type of the downstream aggregation result</dd>
<dd><code>A</code> - downstream aggregation's accumulator type</dd>
<dd><code>M</code> - output type of the resulting <code>Map</code></dd>
<dt>Parameters:</dt>
<dd><code>keyFn</code> - a function to extract the key from input item</dd>
<dd><code>createMapFn</code> - a function which returns a new, empty <code>Map</code> into
                    which the results will be inserted</dd>
<dd><code>downstream</code> - the downstream aggregate operation</dd>
<dt>See Also:</dt>
<dd><a href="#groupingBy(com.hazelcast.function.FunctionEx)"><code>groupingBy(FunctionEx)</code></a>, 
<a href="#groupingBy(com.hazelcast.function.FunctionEx,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>groupingBy(FunctionEx, AggregateOperation1)</code></a>, 
<a href="#toMap(com.hazelcast.function.FunctionEx,com.hazelcast.function.FunctionEx)"><code>toMap(FunctionEx, FunctionEx)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reducing(A,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.BinaryOperatorEx)">
<h3 id="reducing(java.lang.Object,com.hazelcast.function.FunctionEx,com.hazelcast.function.BinaryOperatorEx,com.hazelcast.function.BinaryOperatorEx)">reducing</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;A&gt;,&#8203;A&gt;</span>&nbsp;<span class="member-name">reducing</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
A&nbsp;emptyAccValue,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends A&gt;&nbsp;toAccValueFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;A&gt;&nbsp;combineAccValuesFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html" title="class or interface in javax.annotation" class="external-link">@Nullable</a>
<a href="../../function/BinaryOperatorEx.html" title="interface in com.hazelcast.function">BinaryOperatorEx</a>&lt;A&gt;&nbsp;deductAccValueFn)</span></div>
<div class="block">Returns an aggregate operation that constructs the result through the
 process of <em>immutable reduction</em>:
 <ol>
     <li>The initial accumulated value is <code>emptyAccValue</code>.
     <li>For each input item, compute the new value:
     <code>newVal = combineAccValues(currVal, toAccValue(item))</code>
 </ol>
 <code>combineAccValuesFn</code> must be <strong>associative</strong> because
 it will also be used to combine partial results, as well as
 <strong>commutative</strong> because the encounter order of items is
 unspecified.
 <p>
 The optional <code>deductAccValueFn</code> allows Jet to compute the sliding
 window in O(1) time. It must undo the effects of a previous <code>
 combineAccValuesFn</code> call:
 <pre>
     A accVal;  // has some pre-existing value
     A itemAccVal = toAccValueFn.apply(item);
     A combined = combineAccValuesFn.apply(accVal, itemAccVal);
     A deducted = deductAccValueFn.apply(combined, itemAccVal);
     assert deducted.equals(accVal);
 </pre>
 <p>
 This sample takes a stream of product orders and outputs a single <code>
 long</code> number which is the sum total of all the ordered amounts. The
 aggregate operation it implements is equivalent to <a href="#summingLong(com.hazelcast.function.ToLongFunctionEx)"><code>summingLong(com.hazelcast.function.ToLongFunctionEx&lt;? super T&gt;)</code></a>:
 <pre><code>
 BatchStage&lt;Order&gt; orders = pipeline.readFrom(orderSource);
 BatchStage&lt;Long&gt; totalAmount = orders.aggregate(reducing(
         0L,
         Order::getAmount,
         Math::addExact,
         Math::subtractExact
 ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>A</code> - type of the accumulated value</dd>
<dt>Parameters:</dt>
<dd><code>emptyAccValue</code> - the reducing operation's emptyAccValue element</dd>
<dd><code>toAccValueFn</code> - transforms the stream item into its accumulated value</dd>
<dd><code>combineAccValuesFn</code> - combines two accumulated values into one</dd>
<dd><code>deductAccValueFn</code> - deducts the right-hand accumulated value from the left-hand one
                        (optional)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="pickAny()">
<h3>pickAny</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../accumulator/MutableReference.html" title="class in com.hazelcast.jet.accumulator">MutableReference</a>&lt;T&gt;,&#8203;T&gt;</span>&nbsp;<span class="member-name">pickAny</span>()</div>
<div class="block">Returns an aggregate operation whose result is an arbitrary item it
 observed, or <code>null</code> if it observed no items.
 <p>
 The implementation of <a href="../pipeline/StageWithWindow.html#distinct()"><code>StageWithWindow.distinct()</code></a> uses this
 operation and, if needed, you can use it directly for the same purpose.
 <p>
 This sample takes a stream of people and outputs a stream of people that
 have distinct last names (same as calling <a href="../pipeline/BatchStageWithKey.html#distinct()"><code>groupingKey(keyFn).distinct()</code></a>:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;Entry&lt;String, Person&gt;&gt; distinctByLastName =
         people.groupingKey(Person::getLastName)
               .aggregate(pickAny());
 </code></pre>
 <strong>NOTE:</strong> if this aggregate operation doesn't observe any
 items, its result will be <code>null</code>. Since the non-keyed <a href="../pipeline/BatchStage.html#aggregate(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>BatchStage.aggregate(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T, ?, ? extends R&gt;)</code></a> emits just the naked aggregation result, and since
 a <code>null</code> cannot travel through a Jet pipeline, you will not get
 any output in that case.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sorting(com.hazelcast.function.ComparatorEx)">
<h3>sorting</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" title="class or interface in java.util" class="external-link">ArrayList</a>&lt;T&gt;,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;T&gt;&gt;</span>&nbsp;<span class="member-name">sorting</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/ComparatorEx.html" title="interface in com.hazelcast.function">ComparatorEx</a>&lt;? super T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns an aggregate operation that accumulates all input items into an
 <code>ArrayList</code> and sorts it with the given comparator. If you have
 <code>Comparable</code> items that you want to sort in their natural order, use
 <a href="../../function/ComparatorEx.html#naturalOrder()"><code>ComparatorEx.naturalOrder()</code></a>.
 <p>
 This sample takes a stream of people and outputs a single list of people
 sorted by their last name:
 <pre><code>
 BatchStage&lt;Person&gt; people = pipeline.readFrom(peopleSource);
 BatchStage&lt;List&lt;Person&gt;&gt; sorted = people.aggregate(
     sorting(ComparatorEx.comparing(Person::getLastName)));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - the type of input items</dd>
<dt>Parameters:</dt>
<dd><code>comparator</code> - the comparator to use for sorting</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)">
<h3>allOf</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1,&#8203;
R&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;R&gt;</span>&nbsp;<span class="member-name">allOf</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super R0,&#8203;? super R1,&#8203;? extends R&gt;&nbsp;exportFinishFn)</span></div>
<div class="block">Returns an aggregate operation that is a composite of two aggregate
 operations. It allows you to calculate both aggregations over the same
 items at once.
 <p>
 This sample takes a stream of orders and outputs a single tuple
 containing the orders with the smallest and the largest amount:
 <pre><code>
 BatchStage&lt;Order&gt; orders = pipeline.readFrom(orderSource);
 BatchStage&lt;Tuple2&lt;Order, Order&gt;&gt; extremes = orders.aggregate(allOf(
         minBy(ComparatorEx.comparing(Order::getAmount)),
         maxBy(ComparatorEx.comparing(Order::getAmount)),
         Tuple2::tuple2
 ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of input items</dd>
<dd><code>A0</code> - 1st accumulator type</dd>
<dd><code>A1</code> - 2nd accumulator type</dd>
<dd><code>R0</code> - 1st result type</dd>
<dd><code>R1</code> - 2nd result type</dd>
<dd><code>R</code> - final result type</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - 1st operation</dd>
<dd><code>op1</code> - 2nd operation</dd>
<dd><code>exportFinishFn</code> - function combining the two results into a single target instance</dd>
<dt>Returns:</dt>
<dd>the composite operation</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>allOf</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;</span>&nbsp;<span class="member-name">allOf</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;R0&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;R1&gt;&nbsp;op2)</span></div>
<div class="block">Convenience for <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>allOf(AggregateOperation1, AggregateOperation1,
 BiFunctionEx)</code></a> wrapping the two results in a <a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel"><code>Tuple2</code></a>.</div>
</section>
</li>
<li>
<section class="detail" id="allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)">
<h3>allOf</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2,&#8203;
R&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;R&gt;</span>&nbsp;<span class="member-name">allOf</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super R0,&#8203;? super R1,&#8203;? super R2,&#8203;? extends R&gt;&nbsp;exportFinishFn)</span></div>
<div class="block">Returns an aggregate operation that is a composite of three aggregate
 operations. It allows you to calculate all three over the same items
 at once.
 <p>
 This sample takes a stream of orders and outputs a single tuple
 containing the average amount ordered and the orders with the smallest
 and the largest amount:
 <pre><code>
 BatchStage&lt;Order&gt; orders = pipeline.readFrom(orderSource);
 BatchStage&lt;Tuple3&lt;Double, Order, Order&gt;&gt; averageAndExtremes =
     orders.aggregate(allOf(
         averagingLong(Order::getAmount),
         minBy(ComparatorEx.comparing(Order::getAmount)),
         maxBy(ComparatorEx.comparing(Order::getAmount)),
         Tuple3::tuple3
 ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of input items</dd>
<dd><code>A0</code> - 1st accumulator type</dd>
<dd><code>A1</code> - 2nd accumulator type</dd>
<dd><code>A2</code> - 3rd accumulator type</dd>
<dd><code>R0</code> - 1st result type</dd>
<dd><code>R1</code> - 2nd result type</dd>
<dd><code>R2</code> - 3rd result type</dd>
<dd><code>R</code> - final result type</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - 1st operation</dd>
<dd><code>op1</code> - 2nd operation</dd>
<dd><code>op2</code> - 3rd operation</dd>
<dd><code>exportFinishFn</code> - function combining the three results into a single target instance</dd>
<dt>Returns:</dt>
<dd>the composite operation</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>allOf</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;</span>
<span class="return-type"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;T,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;</span>&nbsp;<span class="member-name">allOf</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2)</span></div>
<div class="block">Convenience for <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)"><code>allOf(AggregateOperation1, AggregateOperation1,
 AggregateOperation1, TriFunction)</code></a> wrapping the three results in a
 <a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel"><code>Tuple3</code></a>.</div>
</section>
</li>
<li>
<section class="detail" id="allOfBuilder()">
<h3>allOfBuilder</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type"><a href="AllOfAggregationBuilder.html" title="class in com.hazelcast.jet.aggregate">AllOfAggregationBuilder</a>&lt;T&gt;</span>&nbsp;<span class="member-name">allOfBuilder</span>()</div>
<div class="block">Returns a builder object that helps you create a composite of multiple
 aggregate operations. The resulting aggregate operation will perform all
 of the constituent operations at the same time and you can retrieve
 individual results from the <a href="../datamodel/ItemsByTag.html" title="class in com.hazelcast.jet.datamodel"><code>ItemsByTag</code></a> object you'll get in the
 output.
 <p>
 The builder object is primarily intended to build a composite of four or
 more aggregate operations. For up to three operations, prefer the simpler
 and more type-safe variants <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>allOf(op1, op2)</code></a> and <a href="#allOf(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>allOf(op1, op2, op3)</code></a>.
 <p>
 In the following sample we'll construct a composite aggregate operation
 that takes a stream of orders and finds the extremes in terms of ordered
 amount. Here's the input stage:
 <pre><code>
 BatchStage&lt;Order&gt; orders = pipeline.readFrom(orderSource);
 </code></pre>

 Now we construct the aggregate operation using the builder:

 <pre><code>
 AllOfAggregationBuilder&lt;Order&gt; builder = allOfBuilder();
 Tag&lt;Order&gt; minTag = builder.add(minBy(ComparatorEx.comparing(Order::getAmount)));
 Tag&lt;Order&gt; maxTag = builder.add(maxBy(ComparatorEx.comparing(Order::getAmount)));
 AggregateOperation1&lt;Order, ?, ItemsByTag&gt; aggrOp = builder.build();
 </code></pre>

 Finally, we apply the aggregate operation and use the tags we got
 above to extract the components:

 <pre><code>
 BatchStage&lt;ItemsByTag&gt; extremes = orders.aggregate(aggrOp);
 BatchStage&lt;Tuple2&lt;Order, Order&gt;&gt; extremesAsTuple =
         extremes.map(ibt -&gt; tuple2(ibt.get(minTag), ibt.get(maxTag)));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of input items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)">
<h3>aggregateOperation2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T0,&#8203;
A0,&#8203;
R0,&#8203;
T1,&#8203;
A1,&#8203;
R1,&#8203;
R&gt;</span>
<span class="return-type"><a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;T0,&#8203;T1,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;R&gt;</span>&nbsp;<span class="member-name">aggregateOperation2</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super R0,&#8203;? super R1,&#8203;? extends R&gt;&nbsp;exportFinishFn)</span></div>
<div class="block">Returns an aggregate operation that is a composite of two independent
 aggregate operations, each one accepting its own input. You need this
 kind of operation in a two-way co-aggregating pipeline stage such as
 <a href="../pipeline/BatchStage.html#aggregate2(com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation2)"><code>BatchStage.aggregate2(BatchStage, AggregateOperation2)</code></a>
 stage0.aggregate2(stage1, compositeAggrOp)}. Before using this method,
 see if you can instead use <a href="../pipeline/BatchStage.html#aggregate2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage0.aggregate2(aggrOp0, stage1, aggrOp1)</code></a> because it's simpler and
 doesn't require you to pre-compose the aggregate operations.
 <p>
 This method is suitable when you can express your computation as two
 independent aggregate operations where you combine their final results.
 If you need an operation that combines the two inputs in the
 accumulation phase, you can create an aggregate operation by specifying
 each primitive using the <a href="AggregateOperation.html#withCreate(com.hazelcast.function.SupplierEx)">aggregate operation builder</a>.
 <p>
 As a quick example, let's say you have two data streams coming from an
 online store, consisting of user actions: page visits and payments:
 <pre><code>
 BatchStage&lt;PageVisit&gt; pageVisits = pipeline.readFrom(pageVisitSource);
 BatchStage&lt;Payment&gt; payments = pipeline.readFrom(paymentSource);
 </code></pre>
 We want to find out how many page clicks each user did before buying a
 product. We can do it like this:
 <pre><code>
 BatchStage&lt;Entry&lt;Long, Double&gt;&gt; visitsPerPurchase = pageVisits
     .groupingKey(PageVisit::userId)
     .aggregate2(
         payments.groupingKey(Payment::userId),
         aggregateOperation2(counting(), counting(),
             (numPageVisits, numPayments) -&gt; 1.0 * numPageVisits / numPayments
         ));
 </code></pre>
 The output stage's stream contains a <code>Map.Entry</code> where the key is
 the user ID and the value is the ratio of page visits to payments for
 that user.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T0</code> - type of items in the first stage</dd>
<dd><code>A0</code> - type of the first aggregate operation's accumulator</dd>
<dd><code>R0</code> - type of the first aggregate operation's result</dd>
<dd><code>T1</code> - type of items in the second stage</dd>
<dd><code>A1</code> - type of the second aggregate operation's accumulator</dd>
<dd><code>R1</code> - type of the second aggregate operation's result</dd>
<dd><code>R</code> - type of the result</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - the aggregate operation that will receive the first stage's input</dd>
<dd><code>op1</code> - the aggregate operation that will receive the second stage's input</dd>
<dd><code>exportFinishFn</code> - the function that transforms the individual aggregate results into the
                 overall result that the co-aggregating stage emits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregateOperation2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T0,&#8203;
T1,&#8203;
A0,&#8203;
A1,&#8203;
R0,&#8203;
R1&gt;</span>
<span class="return-type"><a href="AggregateOperation2.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation2</a>&lt;T0,&#8203;T1,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;A0,&#8203;A1&gt;,&#8203;<a href="../datamodel/Tuple2.html" title="class in com.hazelcast.jet.datamodel">Tuple2</a>&lt;R0,&#8203;R1&gt;&gt;</span>&nbsp;<span class="member-name">aggregateOperation2</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1)</span></div>
<div class="block">Convenience for <a href="#aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>aggregateOperation2(aggrOp0, aggrOp1, finishFn)</code></a> that outputs a
 <code>Tuple2(result0, result1)</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T0</code> - type of items in the first stage</dd>
<dd><code>A0</code> - type of the first aggregate operation's accumulator</dd>
<dd><code>R0</code> - type of the first aggregate operation's result</dd>
<dd><code>T1</code> - type of items in the second stage</dd>
<dd><code>A1</code> - type of the second aggregate operation's accumulator</dd>
<dd><code>R1</code> - type of the second aggregate operation's result</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - the aggregate operation that will receive the first stage's input</dd>
<dd><code>op1</code> - the aggregate operation that will receive the second stage's input</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)">
<h3>aggregateOperation3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T0,&#8203;
T1,&#8203;
T2,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2,&#8203;
R&gt;</span>
<span class="return-type"><a href="AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;T0,&#8203;T1,&#8203;T2,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;R&gt;</span>&nbsp;<span class="member-name">aggregateOperation3</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super R0,&#8203;? super R1,&#8203;? super R2,&#8203;? extends R&gt;&nbsp;exportFinishFn)</span></div>
<div class="block">Returns an aggregate operation that is a composite of three independent
 aggregate operations, each one accepting its own input. You need this
 kind of operation in the three-way co-aggregating pipeline stage:
 <a href="../pipeline/BatchStage.html#aggregate3(com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation3)"><code>BatchStage.aggregate3(BatchStage, BatchStage, AggregateOperation3)</code></a>
 stage0.aggregate3(stage1, stage2, compositeAggrOp)}. Before using this
 method, see if you can instead use <a href="../pipeline/BatchStage.html#aggregate3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.pipeline.BatchStage,com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage0.aggregate3(aggrOp0, stage1,
 aggrOp1, stage2, aggrOp2)</code></a> because it's simpler and doesn't require you
 to pre-compose the aggregate operations.
 <p>
 This method is suitable when you can express your computation as three
 independent aggregate operations where you combine their final results.
 If you need an operation that combines the inputs in the accumulation
 phase, you can create an aggregate operation by specifying each
 primitive using the <a href="AggregateOperation.html#withCreate(com.hazelcast.function.SupplierEx)">aggregate
 operation builder</a>.
 <p>
 As a quick example, let's say you have three data streams coming from an
 online store, consisting of user actions: page visits, add-to-cart
 actions and payments:
 <pre><code>
 BatchStage&lt;PageVisit&gt; pageVisits = pipeline.readFrom(pageVisitSource);
 BatchStage&lt;AddToCart&gt; addToCarts = pipeline.readFrom(addToCartSource);
 BatchStage&lt;Payment&gt; payments = pipeline.readFrom(paymentSource);
 </code></pre>
 We want to get these metrics per each user: how many page clicks they
 did before buying a product, and how many products they bought per
 purchase. We could do it like this:
 <pre><code>
 BatchStage&lt;Entry&lt;Integer, Tuple2&lt;Double, Double&gt;&gt;&gt; userStats = pageVisits
     .groupingKey(PageVisit::userId)
     .aggregate3(
         addToCarts.groupingKey(AddToCart::userId),
         payments.groupingKey(Payment::userId),
         aggregateOperation3(counting(), counting(), counting(),
             (numPageVisits, numAddToCarts, numPayments) -&gt;
                 tuple2(1.0 * numPageVisits / numPayments,
                        1.0 * numAddToCarts / numPayments
                 )
         ));
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T0</code> - type of items in the first stage</dd>
<dd><code>A0</code> - type of the first aggregate operation's accumulator</dd>
<dd><code>R0</code> - type of the first aggregate operation's result</dd>
<dd><code>T1</code> - type of items in the second stage</dd>
<dd><code>A1</code> - type of the second aggregate operation's accumulator</dd>
<dd><code>R1</code> - type of the second aggregate operation's result</dd>
<dd><code>T2</code> - type of items in the third stage</dd>
<dd><code>A2</code> - type of the third aggregate operation's accumulator</dd>
<dd><code>R2</code> - type of the third aggregate operation's result</dd>
<dd><code>R</code> - type of the result</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - the aggregate operation that will receive the first stage's input</dd>
<dd><code>op1</code> - the aggregate operation that will receive the second stage's input</dd>
<dd><code>op2</code> - the aggregate operation that will receive the third stage's input</dd>
<dd><code>exportFinishFn</code> - the function that transforms the individual aggregate results into the
                 overall result that the co-aggregating stage emits</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>aggregateOperation3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T0,&#8203;
T1,&#8203;
T2,&#8203;
A0,&#8203;
A1,&#8203;
A2,&#8203;
R0,&#8203;
R1,&#8203;
R2&gt;</span>
<span class="return-type"><a href="AggregateOperation3.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation3</a>&lt;T0,&#8203;T1,&#8203;T2,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;A0,&#8203;A1,&#8203;A2&gt;,&#8203;<a href="../datamodel/Tuple3.html" title="class in com.hazelcast.jet.datamodel">Tuple3</a>&lt;R0,&#8203;R1,&#8203;R2&gt;&gt;</span>&nbsp;<span class="member-name">aggregateOperation3</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T0,&#8203;A0,&#8203;? extends R0&gt;&nbsp;op0,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T1,&#8203;A1,&#8203;? extends R1&gt;&nbsp;op1,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T2,&#8203;A2,&#8203;? extends R2&gt;&nbsp;op2)</span></div>
<div class="block">Convenience for <a href="#aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)"><code>aggregateOperation3(aggrOp0, aggrOp1, aggrOp2, finishFn)</code></a> that outputs a
 <code>Tuple3(result0, result1, result2)</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T0</code> - type of items in the first stage</dd>
<dd><code>A0</code> - type of the first aggregate operation's accumulator</dd>
<dd><code>R0</code> - type of the first aggregate operation's result</dd>
<dd><code>T1</code> - type of items in the second stage</dd>
<dd><code>A1</code> - type of the second aggregate operation's accumulator</dd>
<dd><code>R1</code> - type of the second aggregate operation's result</dd>
<dd><code>T2</code> - type of items in the third stage</dd>
<dd><code>A2</code> - type of the third aggregate operation's accumulator</dd>
<dd><code>R2</code> - type of the third aggregate operation's result</dd>
<dt>Parameters:</dt>
<dd><code>op0</code> - the aggregate operation that will receive the first stage's input</dd>
<dd><code>op1</code> - the aggregate operation that will receive the second stage's input</dd>
<dd><code>op2</code> - the aggregate operation that will receive the third stage's input</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="coAggregateOperationBuilder()">
<h3>coAggregateOperationBuilder</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="CoAggregateOperationBuilder.html" title="class in com.hazelcast.jet.aggregate">CoAggregateOperationBuilder</a></span>&nbsp;<span class="member-name">coAggregateOperationBuilder</span>()</div>
<div class="block">Returns a builder object that offers a step-by-step fluent API to create
 an aggregate operation that accepts multiple inputs. You must supply
 this kind of operation to a co-aggregating pipeline stage. You need this
 builder if you're using the <a href="../pipeline/BatchStage.html#aggregateBuilder()"><code>stage.aggregateBuilder()</code></a>. Before deciding to use it, consider using
 <a href="../pipeline/BatchStage.html#aggregateBuilder(com.hazelcast.jet.aggregate.AggregateOperation1)"><code>stage.aggregateBuilder(aggrOp0)</code></a> because it will allow you to directly
 pass the aggregate operation for each joined stage, without requiring
 you to build a composite operation through this builder. Finally, if
 you're co-aggregating two or three streams, prefer the simpler and more
 type-safe variants: <a href="#aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.function.BiFunctionEx)"><code>aggregateOperation2(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T0, A0, ? extends R0&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T1, A1, ? extends R1&gt;, com.hazelcast.function.BiFunctionEx&lt;? super R0, ? super R1, ? extends R&gt;)</code></a> and <a href="#aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.aggregate.AggregateOperation1,com.hazelcast.jet.function.TriFunction)"><code>aggregateOperation3(com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T0, A0, ? extends R0&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T1, A1, ? extends R1&gt;, com.hazelcast.jet.aggregate.AggregateOperation1&lt;? super T2, A2, ? extends R2&gt;, com.hazelcast.jet.function.TriFunction&lt;? super R0, ? super R1, ? super R2, ? extends R&gt;)</code></a>.
 <p>
 This builder is suitable when you can express your computation as
 independent aggregate operations on each input where you combine only
 their final results. If you need an operation that combines the inputs
 in the accumulation phase, you can create an aggregate operation by
 specifying each primitive using the <a href="AggregateOperation.html#withCreate(com.hazelcast.function.SupplierEx)">aggregate operation builder</a>.
 <p>
 As a quick example, let's say you have two data streams coming from an
 online store, consisting of user actions: page visits and payments:
 <pre><code>
 BatchStage&lt;PageVisit&gt; pageVisits = pipeline.readFrom(pageVisitSource);
 BatchStage&lt;Payment&gt; payments = pipeline.readFrom(paymentSource);
 </code></pre>
 We want to find out how many page clicks each user did before buying a
 product, and we want to do it using <a href="../pipeline/BatchStage.html#aggregateBuilder()"><code>stage.aggregateBuilder()</code></a>. Note that there will be two builders at play:
 the <em>stage builder</em>, which joins the pipeline stages, and the
 <em>aggregate operation builder</em> (obtained from this method). First
 we obtain the stage builder and add our pipeline stages:

 <pre><code>
 GroupAggregateBuilder1&lt;PageVisit, Long&gt; stageBuilder =
         pageVisits.groupingKey(PageVisit::userId).aggregateBuilder();
 Tag&lt;PageVisit&gt; visitTag_in = stageBuilder.tag0();
 Tag&lt;Payment&gt; payTag_in = stageBuilder.add(payments.groupingKey(Payment::userId));
 </code></pre>

 Now we have the tags we need to build the aggregate operation, and while
 building it we get new tags to get the results of the operation:

 <pre><code>
 CoAggregateOperationBuilder opBuilder = coAggregateOperationBuilder();
 Tag&lt;Long&gt; visitTag = opBuilder.add(visitTag_in, counting());
 Tag&lt;Long&gt; payTag = opBuilder.add(payTag_in, counting());
 </code></pre>

 We use these tags in the <code>exportFinishFn</code> we specify at the end:

 <pre><code>
 AggregateOperation&lt;Object[], Double&gt; aggrOp =
         opBuilder.build(ibt -&gt; 1.0 * ibt.get(visitTag) / ibt.get(payTag));
 </code></pre>

 And now we're ready to construct the output stage:

 <pre><code>
 BatchStage&lt;Entry&lt;Long, Double&gt;&gt; visitsPerPurchase = stageBuilder.build(aggrOp);
 </code></pre>

 The output stage's stream contains <code>Map.Entry</code>s where the key is
 the user ID and the value is the ratio of page visits to payments for
 that user.</div>
</section>
</li>
<li>
<section class="detail" id="toCollector(com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>toCollector</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" title="class or interface in java.util.stream" class="external-link">Collector</a>&lt;T,&#8203;A,&#8203;R&gt;</span>&nbsp;<span class="member-name">toCollector</span>&#8203;(<span class="parameters"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Adapts this aggregate operation to a collector which can be passed to
 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect(java.util.stream.Collector)" title="class or interface in java.util.stream" class="external-link"><code>Stream.collect(Collector)</code></a>.
 <p>
 This can be useful when you want to combine java.util.stream with Jet
 aggregations. For example, the below can be used to do multiple aggregations
 in a single pass over the same data set:
 <pre><code>
   Stream&lt;Person&gt; personStream = people.stream();
   personStream.collect(
     AggregateOperations.toCollector(
       AggregateOperations.allOf(
         AggregateOperations.counting(),
         AggregateOperations.averagingLong(p -&gt; p.getAge())
       )
     )
   );
 </code></pre></div>
</section>
</li>
<li>
<section class="detail" id="toAggregator(com.hazelcast.jet.aggregate.AggregateOperation1)">
<h3>toAggregator</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../aggregation/Aggregator.html" title="interface in com.hazelcast.aggregation">Aggregator</a>&lt;T,&#8203;R&gt;</span>&nbsp;<span class="member-name">toAggregator</span>&#8203;(<span class="parameters"><a href="AggregateOperation1.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation1</a>&lt;? super T,&#8203;A,&#8203;? extends R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Adapts this aggregate operation to be used for <a href="../../map/IMap.html#aggregate(com.hazelcast.aggregation.Aggregator)"><code>IMap.aggregate(Aggregator)</code></a>
 calls.
 <p>
 Using <code>IMap</code> aggregations can be desirable when you want to make
 use of <a href="../../map/IMap.html#addIndex(com.hazelcast.config.IndexType,java.lang.String...)">indices</a> when doing aggregations and
 want to use the Jet aggregations API instead of writing a custom
 <a href="../../aggregation/Aggregator.html" title="interface in com.hazelcast.aggregation"><code>Aggregator</code></a>.
 <p>
 For example, the following aggregation can be used to group people by
 their age and find the counts for each group.
 <pre><code>
   IMap&lt;Integer, Person&gt; map = jet.getMap("people");
   Map&lt;Integer, Long&gt; counts = map.aggregate(
     AggregateOperations.toAggregator(
       AggregateOperations.groupingBy(
         e -&gt; e.getValue().getGender(), AggregateOperations.counting()
       )
     )
   );
 </code>
 </pre></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/AggregateOperations.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
