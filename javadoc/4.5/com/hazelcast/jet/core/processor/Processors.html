<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Tue Apr 20 14:42:57 CEST 2021 -->
<title>Processors (hazelcast-jet-distribution 4.5 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-04-20">
<meta name="description" content="declaration: package: com.hazelcast.jet.core.processor, class: Processors">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Processors.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.jet.core.processor</a></div>
<h1 title="Class Processors" class="title">Class Processors</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.hazelcast.jet.core.processor.Processors</div>
</div>
<section class="description">
<hr>
<pre>public final class <span class="type-name-label">Processors</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></pre>
<div class="block">Static utility class with factory methods for Jet processors. These are
 meant to implement the internal vertices of the DAG; for other kinds of
 processors refer to the <a href="package-summary.html">package-level documentation</a>.
 <p>
 Many of the processors deal with an aggregating operation over stream
 items. Prior to aggregation items may be grouped by an arbitrary key
 and/or an event timestamp-based window. There are two main aggregation
 setups: single-stage and two-stage.
 <p>
 Unless specified otherwise, all functions passed to member methods must
 be stateless.

 <h1>Single-stage aggregation</h1>

 This is the basic setup where all the aggregation steps happen in one
 vertex. The input must be properly partitioned and distributed. For
 non-aligned window aggregation (e.g., session-based, trigger-based,
 etc.) this is the only choice. In the case of aligned windows it is the
 best choice if the source is already partitioned by the grouping key
 because the inbound edge will not have to be distributed. If the input
 stream needs repartitioning, this setup will incur heavier network
 traffic than the two-stage setup due to the need for a
 distributed-partitioned edge. On the other hand, it will use less memory
 because each member keeps track only of the keys belonging to its own
 partitions. This is the DAG outline for the case where upstream data
 is not localized by grouping key:
 <pre>
                 -----------------
                | upstream vertex |
                 -----------------
                         |
                         | partitioned-distributed
                         V
                    -----------
                   | aggregate |
                    -----------
 </pre>

 <h1>Two-stage aggregation</h1>

 In two-stage aggregation, the first stage applies just the
 <a href="../../aggregate/AggregateOperation1.html#accumulateFn()"><code>accumulate</code></a> aggregation
 primitive and the second stage does <a href="../../aggregate/AggregateOperation.html#combineFn()"><code>combine</code></a> and <a href="../../aggregate/AggregateOperation.html#finishFn()"><code>finish</code></a>. The essential property
 of this setup is that the edge leading to the first stage is local,
 incurring no network traffic, and only the edge from the first to the
 second stage is distributed. There is only one item per group traveling on
 the distributed edge. Compared to the single-stage setup this can
 dramatically reduce network traffic, but it needs more memory to keep
 track of all keys on each cluster member. This is the outline of the DAG:
 <pre>
                -----------------
               | upstream vertex |
                -----------------
                        |
                        | partitioned-local
                        V
                  ------------
                 | accumulate |
                  ------------
                        |
                        | partitioned-distributed
                        V
                 ----------------
                | combine/finish |
                 ----------------
 </pre>
 The variants without a grouping key are equivalent to grouping by a
 single, global key. In that case the edge towards the final-stage
 vertex must be all-to-one and the local parallelism of the vertex must
 be one. Unless the volume of the aggregated data is small (e.g., some
 side branch off the main flow in the DAG), the best choice is this
 two-stage setup:
 <pre>
                -----------------
               | upstream vertex |
                -----------------
                        |
                        | local, non-partitioned
                        V
                  ------------
                 | accumulate |
                  ------------
                        |
                        | distributed, all-to-one
                        V
                 ----------------
                | combine/finish | localParallelism = 1
                 ----------------
 </pre>
 This will parallelize and distributed most of the processing and
 the second-stage processor will receive just a single item from
 each upstream processor, doing very little work.

 <h1>Overview of factory methods for aggregate operations</h1>
 <table border="1" summary="Overview of factory methods for aggregate operations">
 <tr>
     <th></th>
     <th>single-stage</th>
     <th>stage 1/2</th>
     <th>stage 2/2</th>
 </tr><tr>
     <th>batch,<br>no grouping</th>

     <td><a href="#aggregateP(com.hazelcast.jet.aggregate.AggregateOperation)"><code>aggregateP(com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;)</code></a></td>
     <td><a href="#accumulateP(com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateP(com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;)</code></a></td>
     <td><a href="#combineP(com.hazelcast.jet.aggregate.AggregateOperation)"><code>combineP(com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;)</code></a></td>
 </tr><tr>
     <th>batch, group by key</th>

     <td><a href="#aggregateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)"><code>aggregateByKeyP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;, com.hazelcast.function.BiFunctionEx&lt;? super K, ? super R, OUT&gt;)</code></a></td>
     <td><a href="#accumulateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByKeyP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ?&gt;)</code></a></td>
     <td rowspan='2'><a href="#combineByKeyP(com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)"><code>combineByKeyP(com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;, com.hazelcast.function.BiFunctionEx&lt;? super K, ? super R, OUT&gt;)</code></a></td>
 </tr><tr>
     <th>batch, co-group by key</th>

     <td><a href="#aggregateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)"><code>aggregateByKeyP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;, com.hazelcast.function.BiFunctionEx&lt;? super K, ? super R, OUT&gt;)</code></a></td>
     <td><a href="#accumulateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByKeyP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ?&gt;)</code></a></td>
 </tr><tr>
     <th>stream, group by key<br>and aligned window</th>

     <td><a href="#aggregateToSlidingWindowP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,long,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)"><code>aggregateToSlidingWindowP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, java.util.List&lt;com.hazelcast.function.ToLongFunctionEx&lt;?&gt;&gt;, com.hazelcast.jet.core.TimestampKind, com.hazelcast.jet.core.SlidingWindowPolicy, long, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ? extends R&gt;, com.hazelcast.jet.core.function.KeyedWindowResultFunction&lt;? super K, ? super R, ? extends OUT&gt;)</code></a></td>
     <td><a href="#accumulateByFrameP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByFrameP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, java.util.List&lt;com.hazelcast.function.ToLongFunctionEx&lt;?&gt;&gt;, com.hazelcast.jet.core.TimestampKind, com.hazelcast.jet.core.SlidingWindowPolicy, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ?&gt;)</code></a></td>
     <td rowspan='2'><a href="#combineToSlidingWindowP(com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)"><code>combineToSlidingWindowP(com.hazelcast.jet.core.SlidingWindowPolicy, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ? extends R&gt;, com.hazelcast.jet.core.function.KeyedWindowResultFunction&lt;? super K, ? super R, ? extends OUT&gt;)</code></a></td>
 </tr><tr>
     <th>stream, co-group by key<br>and aligned window</th>

     <td><a href="#aggregateToSlidingWindowP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,long,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)"><code>aggregateToSlidingWindowP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, java.util.List&lt;com.hazelcast.function.ToLongFunctionEx&lt;?&gt;&gt;, com.hazelcast.jet.core.TimestampKind, com.hazelcast.jet.core.SlidingWindowPolicy, long, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ? extends R&gt;, com.hazelcast.jet.core.function.KeyedWindowResultFunction&lt;? super K, ? super R, ? extends OUT&gt;)</code></a></td>
     <td><a href="#accumulateByFrameP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByFrameP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, java.util.List&lt;com.hazelcast.function.ToLongFunctionEx&lt;?&gt;&gt;, com.hazelcast.jet.core.TimestampKind, com.hazelcast.jet.core.SlidingWindowPolicy, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ?&gt;)</code></a></td>
 </tr><tr>
     <th>stream, group by key<br>and session window</th>
     <td><a href="#aggregateToSessionWindowP(long,long,java.util.List,java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)"><code>aggregateToSessionWindowP(long, long, java.util.List&lt;com.hazelcast.function.ToLongFunctionEx&lt;?&gt;&gt;, java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ? extends R&gt;, com.hazelcast.jet.core.function.KeyedWindowResultFunction&lt;? super K, ? super R, ? extends OUT&gt;)</code></a></td>
     <td>N/A</td>
     <td>N/A</td>
 </tr></table>
 <p>
 Tumbling window is a special case of sliding window with sliding step =
 window size.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>3.0</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>static &lt;K,&#8203;
A&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#accumulateByFrameP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation)">accumulateByFrameP</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="../TimestampKind.html" title="enum in com.hazelcast.jet.core">TimestampKind</a>&nbsp;timestampKind,
<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;?&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for the first-stage vertex in a
 two-stage sliding window aggregation setup (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages).</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>static &lt;K,&#8203;
A&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#accumulateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation)">accumulateByKeyP</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;getKeyFns,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;?&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for the first-stage vertex in a
 two-stage group-and-aggregate setup.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>static &lt;A,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#accumulateP(com.hazelcast.jet.aggregate.AggregateOperation)">accumulateP</a></span>&#8203;(<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that performs the
 accumulation step of the provided aggregate operation on all the items
 it receives.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>static &lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;<br><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)">aggregateByKeyP</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp,
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super K,&#8203;? super R,&#8203;OUT&gt;&nbsp;mapToOutputFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that groups items by key
 and performs the provided aggregate operation on each group.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>static &lt;A,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateP(com.hazelcast.jet.aggregate.AggregateOperation)">aggregateP</a></span>&#8203;(<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that performs the provided
 aggregate operation on all the items it receives.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>static &lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;<br><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateToSessionWindowP(long,long,java.util.List,java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">aggregateToSessionWindowP</a></span>&#8203;(long&nbsp;sessionTimeout,
long&nbsp;earlyResultsPeriod,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that aggregates events into
 session windows.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>static &lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;<br><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aggregateToSlidingWindowP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,long,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">aggregateToSlidingWindowP</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="../TimestampKind.html" title="enum in com.hazelcast.jet.core">TimestampKind</a>&nbsp;timestampKind,
<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
long&nbsp;earlyResultsPeriod,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that aggregates events
 into a sliding window in a single stage (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages).</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>static &lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;<br><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#combineByKeyP(com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)">combineByKeyP</a></span>&#8203;(<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp,
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super K,&#8203;? super R,&#8203;OUT&gt;&nbsp;mapToOutputFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for the second-stage vertex in a
 two-stage group-and-aggregate setup.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>static &lt;A,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#combineP(com.hazelcast.jet.aggregate.AggregateOperation)">combineP</a></span>&#8203;(<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that performs the
 combining and finishing steps of the provided aggregate operation.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>static &lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;<br><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#combineToSlidingWindowP(com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">combineToSlidingWindowP</a></span>&#8203;(<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for the second-stage vertex in a
 two-stage sliding window aggregation setup (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages).</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterP(com.hazelcast.function.PredicateEx)">filterP</a></span>&#8203;(<a href="../../../function/PredicateEx.html" title="interface in com.hazelcast.function">PredicateEx</a>&lt;? super T&gt;&nbsp;filterFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that emits the same items
 it receives, but only those that pass the given predicate.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>static &lt;C,&#8203;
S,&#8203;
T&gt;&nbsp;<a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#filterUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiPredicateEx)">filterUsingServiceP</a></span>&#8203;(<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="../../../function/BiPredicateEx.html" title="interface in com.hazelcast.function">BiPredicateEx</a>&lt;? super S,&#8203;? super T&gt;&nbsp;filterFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that emits the same items
 it receives, but only those that pass the given predicate.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>static &lt;T,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#flatMapP(com.hazelcast.function.FunctionEx)">flatMapP</a></span>&#8203;(<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;? extends R&gt;&gt;&nbsp;flatMapFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that applies the provided
 item-to-traverser mapping function to each received item and emits all
 the items from the resulting traverser.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
S,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#flatMapStatefulP(long,com.hazelcast.function.FunctionEx,com.hazelcast.function.ToLongFunctionEx,java.util.function.Supplier,com.hazelcast.jet.function.TriFunction,com.hazelcast.jet.function.TriFunction)">flatMapStatefulP</a></span>&#8203;(long&nbsp;ttl,
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;timestampFn,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" title="class or interface in java.util.function" class="external-link">Supplier</a>&lt;? extends S&gt;&nbsp;createFn,
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;statefulFlatMapFn,
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;onEvictFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that performs a stateful
 flat-mapping of its input.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>static &lt;C,&#8203;
S,&#8203;
T,&#8203;
R&gt;&nbsp;<a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#flatMapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)">flatMapUsingServiceP</a></span>&#8203;(<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;flatMapFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that applies the provided
 item-to-traverser mapping function to each received item and emits all
 the items from the resulting traverser.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#insertWatermarksP(com.hazelcast.jet.core.EventTimePolicy)">insertWatermarksP</a></span>&#8203;(<a href="../EventTimePolicy.html" title="class in com.hazelcast.jet.core">EventTimePolicy</a>&lt;? super T&gt;&nbsp;eventTimePolicy)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that inserts <a href="../Watermark.html" title="class in com.hazelcast.jet.core"><code>watermark items</code></a> into the stream.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>static &lt;T,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapP(com.hazelcast.function.FunctionEx)">mapP</a></span>&#8203;(<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends R&gt;&nbsp;mapFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex which, for each received
 item, emits the result of applying the given mapping function to it.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>static &lt;T,&#8203;
K,&#8203;
S,&#8203;
R&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapStatefulP(long,com.hazelcast.function.FunctionEx,com.hazelcast.function.ToLongFunctionEx,java.util.function.Supplier,com.hazelcast.jet.function.TriFunction,com.hazelcast.jet.function.TriFunction)">mapStatefulP</a></span>&#8203;(long&nbsp;ttl,
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;timestampFn,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" title="class or interface in java.util.function" class="external-link">Supplier</a>&lt;? extends S&gt;&nbsp;createFn,
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super T,&#8203;? extends R&gt;&nbsp;statefulMapFn,
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,&#8203;? extends R&gt;&nbsp;onEvictFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that performs a stateful
 mapping of its input.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>static &lt;C,&#8203;
S,&#8203;
T,&#8203;
K,&#8203;
R&gt;<br><a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapUsingServiceAsyncP(com.hazelcast.jet.pipeline.ServiceFactory,int,boolean,com.hazelcast.function.FunctionEx,com.hazelcast.function.BiFunctionEx)">mapUsingServiceAsyncP</a></span>&#8203;(<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
int&nbsp;maxConcurrentOps,
boolean&nbsp;preserveOrder,
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;T,&#8203;K&gt;&nbsp;extractKeyFn,
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" title="class or interface in java.util.concurrent" class="external-link">CompletableFuture</a>&lt;R&gt;&gt;&nbsp;mapAsyncFn)</code></th>
<td class="col-last">
<div class="block">Asynchronous version of <a href="#mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)"><code>mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory&lt;C, S&gt;, com.hazelcast.function.BiFunctionEx&lt;? super S, ? super T, ? extends R&gt;)</code></a>: the <code>
 mapAsyncFn</code> returns a <code>CompletableFuture&lt;R&gt;</code> instead of just
 <code>R</code>.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>static &lt;C,&#8203;
S,&#8203;
T,&#8203;
R&gt;&nbsp;<a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)">mapUsingServiceP</a></span>&#8203;(<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;? extends R&gt;&nbsp;mapFn)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex which, for each received
 item, emits the result of applying the given mapping function to it.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>static <a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#noopP()">noopP</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns a supplier of a processor that swallows all its normal input (if
 any), does nothing with it, forwards the watermarks, produces no output
 and completes immediately.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>static &lt;T&gt;&nbsp;<a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#sortP(java.util.Comparator)">sortP</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" title="class or interface in java.util" class="external-link">Comparator</a>&lt;T&gt;&nbsp;comparator)</code></th>
<td class="col-last">
<div class="block">Returns a supplier of processors for a vertex that sorts its input using
 a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link"><code>PriorityQueue</code></a> and emits it in the <code>complete</code> phase.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="aggregateP(com.hazelcast.jet.aggregate.AggregateOperation)">
<h3>aggregateP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">aggregateP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Returns a supplier of processors for a vertex that performs the provided
 aggregate operation on all the items it receives. After exhausting all
 its input, it emits a single item of type <code>R</code> &mdash; the result of
 the aggregate operation's <a href="../../aggregate/AggregateOperation.html#finishFn()"><code>finish</code></a>
 primitive. The primitive may return <code>null</code>, in that case the vertex
 will not produce any output.
 <p>
 Since the input to this vertex must be bounded, its primary use case are
 batch jobs.
 <p>
 This processor has state, but does not save it to the snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>A</code> - type of accumulator returned from <code>
            aggrOp.createAccumulatorFn()</code></dd>
<dd><code>R</code> - type of the finished result returned from <code>
            aggrOp.finishAccumulationFn()</code></dd>
<dt>Parameters:</dt>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="accumulateP(com.hazelcast.jet.aggregate.AggregateOperation)">
<h3>accumulateP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">accumulateP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Returns a supplier of processors for a vertex that performs the
 accumulation step of the provided aggregate operation on all the items
 it receives. After exhausting all its input, it emits a single item of
 type <code>A</code> &mdash; the accumulator object.
 <p>
 Since the input to this vertex must be bounded, its primary use case are
 batch jobs.
 <p>
 This processor has state, but does not save it to the snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>A</code> - type of accumulator returned from <code>
            aggrOp.createAccumulatorFn()</code></dd>
<dd><code>R</code> - type of the finished result returned from <code>aggrOp.
            finishAccumulationFn()</code></dd>
<dt>Parameters:</dt>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="combineP(com.hazelcast.jet.aggregate.AggregateOperation)">
<h3>combineP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;A,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">combineP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp)</span></div>
<div class="block">Returns a supplier of processors for a vertex that performs the
 combining and finishing steps of the provided aggregate operation. It
 expects to receive the accumulator objects from the upstream <a href="#accumulateP(com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateP(com.hazelcast.jet.aggregate.AggregateOperation&lt;A, R&gt;)</code></a> vertex and combines their state into a single
 accumulator. After exhausting all its input, it emits a single result
 of type <code>R</code> &mdash; the result of applying the <code>finish</code>
 primitive to the combined accumulator. The primitive may return <code>
 null</code>, in that case the vertex will not produce any output.
 <p>
 Since the input to this vertex must be bounded, its primary use case is
 batch jobs.
 <p>
 This processor has state, but does not save it to the snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>A</code> - type of accumulator returned from <code>
            aggrOp.createAccumulatorFn()</code></dd>
<dd><code>R</code> - type of the finished result returned from <code>aggrOp.
            finishAccumulationFn()</code></dd>
<dt>Parameters:</dt>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)">
<h3>aggregateByKeyP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">aggregateByKeyP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super K,&#8203;? super R,&#8203;OUT&gt;&nbsp;mapToOutputFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that groups items by key
 and performs the provided aggregate operation on each group. After
 exhausting all its input it emits one item per distinct key. It computes
 the item to emit by passing each (key, result) pair to <code>
 mapToOutputFn</code>.
 <p>
 The vertex accepts input from one or more inbound edges. The type of
 items may be different on each edge. For each edge a separate key
 extracting function must be supplied and the aggregate operation must
 contain a separate accumulation function for each edge.
 <p>
 This processor has state, but does not save it to snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - type of key</dd>
<dd><code>A</code> - type of accumulator returned from <code>aggrOp.createAccumulatorFn()</code></dd>
<dd><code>R</code> - type of the result returned from <code>aggrOp.finishAccumulationFn()</code></dd>
<dd><code>OUT</code> - type of the item to emit</dd>
<dt>Parameters:</dt>
<dd><code>keyFns</code> - functions that compute the grouping key</dd>
<dd><code>aggrOp</code> - the aggregate operation</dd>
<dd><code>mapToOutputFn</code> - function that takes the key and the aggregation result and returns
                      the output item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="accumulateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation)">
<h3>accumulateByKeyP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">accumulateByKeyP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;getKeyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;?&gt;&nbsp;aggrOp)</span></div>
<div class="block">Returns a supplier of processors for the first-stage vertex in a
 two-stage group-and-aggregate setup. The vertex groups items by the
 grouping key and applies the <a href="../../aggregate/AggregateOperation.html#accumulateFn(com.hazelcast.jet.datamodel.Tag)"><code>accumulate</code></a> primitive to each group.
 After exhausting all its input it emits one <code>Map.Entry&lt;K, A&gt;</code> per
 distinct key.
 <p>
 The vertex accepts input from one or more inbound edges. The type of
 items may be different on each edge. For each edge a separate key
 extracting function must be supplied and the aggregate operation must
 contain a separate accumulation function for each edge.
 <p>
 This processor has state, but does not save it to snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - type of key</dd>
<dd><code>A</code> - type of accumulator returned from <code>aggrOp.createAccumulatorFn()</code></dd>
<dt>Parameters:</dt>
<dd><code>getKeyFns</code> - functions that compute the grouping key</dd>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="combineByKeyP(com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.function.BiFunctionEx)">
<h3>combineByKeyP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">combineByKeyP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;R&gt;&nbsp;aggrOp,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super K,&#8203;? super R,&#8203;OUT&gt;&nbsp;mapToOutputFn)</span></div>
<div class="block">Returns a supplier of processors for the second-stage vertex in a
 two-stage group-and-aggregate setup. Each processor applies the <a href="../../aggregate/AggregateOperation.html#combineFn()"><code>combine</code></a> aggregation primitive to the
 entries received from several upstream instances of <a href="#accumulateByKeyP(java.util.List,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByKeyP(java.util.List&lt;com.hazelcast.function.FunctionEx&lt;?, ? extends K&gt;&gt;, com.hazelcast.jet.aggregate.AggregateOperation&lt;A, ?&gt;)</code></a>. After exhausting all its input it emits one item per
 distinct key. It computes the item to emit by passing each (key, result)
 pair to <code>mapToOutputFn</code>.
 <p>
 Since the input to this vertex must be bounded, its primary use case
 are batch jobs.
 <p>
 This processor has state, but does not save it to snapshot. On job
 restart, the state will be lost.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>A</code> - type of accumulator returned from <code>aggrOp.createAccumulatorFn()</code></dd>
<dd><code>R</code> - type of the finished result returned from
            <code>aggrOp.finishAccumulationFn()</code></dd>
<dd><code>OUT</code> - type of the item to emit</dd>
<dt>Parameters:</dt>
<dd><code>aggrOp</code> - the aggregate operation to perform</dd>
<dd><code>mapToOutputFn</code> - function that takes the key and the aggregation result and returns
                      the output item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateToSlidingWindowP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,long,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">
<h3>aggregateToSlidingWindowP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">aggregateToSlidingWindowP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../TimestampKind.html" title="enum in com.hazelcast.jet.core">TimestampKind</a>&nbsp;timestampKind,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
long&nbsp;earlyResultsPeriod,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that aggregates events
 into a sliding window in a single stage (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages). The vertex
 groups items by the grouping key (as obtained from the given
 key-extracting function) and by <em>frame</em>, which is a range of
 timestamps equal to the sliding step. It emits sliding window results
 labeled with the timestamp denoting the window's end time (the exclusive
 upper bound of the timestamps belonging to the window).
 <p>
 The vertex accepts input from one or more inbound edges. The type of
 items may be different on each edge. For each edge a separate key
 extracting function must be supplied and the aggregate operation must
 contain a separate accumulation function for each edge.
 <p>
 When the vertex receives a watermark with a given <code>wmVal</code>, it
 emits the result of aggregation for all the positions of the sliding
 window with <code>windowTimestamp &lt;= wmVal</code>. It computes the window
 result by combining the partial results of the frames belonging to it
 and finally applying the <code>finish</code> aggregation primitive. After this
 it deletes from storage all the frames that trail behind the emitted
 windows. In the output there is one item per key per window position.
 <p>
 <i>Behavior on job restart</i><br>
 This processor saves its state to snapshot. After restart, it can
 continue accumulating where it left off.
 <p>
 After a restart in at-least-once mode, watermarks are allowed to go back
 in time. If such a watermark is received, some windows that were emitted
 in previous execution will be re-emitted. These windows might miss
 events as some of them had already been evicted before the snapshot was
 done in previous execution.</div>
</section>
</li>
<li>
<section class="detail" id="accumulateByFrameP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation)">
<h3>accumulateByFrameP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">accumulateByFrameP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../TimestampKind.html" title="enum in com.hazelcast.jet.core">TimestampKind</a>&nbsp;timestampKind,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;?&gt;&nbsp;aggrOp)</span></div>
<div class="block">Returns a supplier of processors for the first-stage vertex in a
 two-stage sliding window aggregation setup (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages). The vertex
 groups items by the grouping key (as obtained from the given
 key-extracting function) and by <em>frame</em>, which is a range of
 timestamps equal to the sliding step. It applies the <a href="../../aggregate/AggregateOperation1.html#accumulateFn()"><code>accumulate</code></a> aggregation primitive to
 each key-frame group.
 <p>
 The frame is identified by the timestamp denoting its end time (equal to
 the exclusive upper bound of its timestamp range). <a href="../SlidingWindowPolicy.html#higherFrameTs(long)"><code>SlidingWindowPolicy.higherFrameTs(long)</code></a> maps the event timestamp to the
 timestamp of the frame it belongs to.
 <p>
 The vertex accepts input from one or more inbound edges. The type of
 items may be different on each edge. For each edge a separate key
 extracting function must be supplied and the aggregate operation must
 contain a separate accumulation function for each edge.
 <p>
 When the processor receives a watermark with a given <code>wmVal</code>, it
 emits the current accumulated state of all frames with <code>
 timestamp &lt;= wmVal</code> and deletes these frames from its storage. In the
 output there is one item per key per frame.
 <p>
 When a state snapshot is requested, the state is flushed to second-stage
 processor and nothing is saved to snapshot.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - type of the grouping key</dd>
<dd><code>A</code> - type of accumulator returned from <code>aggrOp.
            createAccumulatorFn()</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="combineToSlidingWindowP(com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">
<h3>combineToSlidingWindowP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">combineToSlidingWindowP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../SlidingWindowPolicy.html" title="class in com.hazelcast.jet.core">SlidingWindowPolicy</a>&nbsp;winPolicy,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</span></div>
<div class="block">Returns a supplier of processors for the second-stage vertex in a
 two-stage sliding window aggregation setup (see the <a href="Processors.html" title="class in com.hazelcast.jet.core.processor"><code>class Javadoc</code></a> for an explanation of aggregation stages). Each
 processor applies the <a href="../../aggregate/AggregateOperation.html#combineFn()"><code>combine</code></a>
 aggregation primitive to the frames received from several upstream
 instances of <a href="#accumulateByFrameP(java.util.List,java.util.List,com.hazelcast.jet.core.TimestampKind,com.hazelcast.jet.core.SlidingWindowPolicy,com.hazelcast.jet.aggregate.AggregateOperation)"><code>accumulateByFrame()</code></a>.
 <p>
 When the processor receives a watermark with a given <code>wmVal</code>,
 it emits the result of aggregation for all positions of the sliding
 window with <code>windowTimestamp &lt;= wmVal</code>. It computes the window
 result by combining the partial results of the frames belonging to it
 and finally applying the <code>finish</code> aggregation primitive. After
 this it deletes from storage all the frames that trail behind the
 emitted windows. To compute the item to emit, it calls <code>
 mapToOutputFn</code> with the window's start and end timestamps, the key and
 the aggregation result. The window end time is the exclusive upper bound
 of the timestamps belonging to the window.
 <p>
 <i>Behavior on job restart</i><br>
 This processor saves its state to snapshot. After restart, it can
 continue accumulating where it left off.
 <p>
 After a restart in at-least-once mode, watermarks are allowed to go back
 in time. If such a watermark is received, some windows that were emitted
 in previous execution will be re-emitted. These windows might miss
 events as some of them had already been evicted before the snapshot was
 done in previous execution.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>A</code> - type of the accumulator</dd>
<dd><code>R</code> - type of the finished result returned from <code>aggrOp.
            finishAccumulationFn()</code></dd>
<dd><code>OUT</code> - type of the item to emit</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aggregateToSessionWindowP(long,long,java.util.List,java.util.List,com.hazelcast.jet.aggregate.AggregateOperation,com.hazelcast.jet.core.function.KeyedWindowResultFunction)">
<h3>aggregateToSessionWindowP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;K,&#8203;
A,&#8203;
R,&#8203;
OUT&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">aggregateToSessionWindowP</span>&#8203;(<span class="parameters">long&nbsp;sessionTimeout,
long&nbsp;earlyResultsPeriod,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;?&gt;&gt;&nbsp;timestampFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;?,&#8203;? extends K&gt;&gt;&nbsp;keyFns,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../aggregate/AggregateOperation.html" title="interface in com.hazelcast.jet.aggregate">AggregateOperation</a>&lt;A,&#8203;? extends R&gt;&nbsp;aggrOp,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../function/KeyedWindowResultFunction.html" title="interface in com.hazelcast.jet.core.function">KeyedWindowResultFunction</a>&lt;? super K,&#8203;? super R,&#8203;? extends OUT&gt;&nbsp;mapToOutputFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that aggregates events into
 session windows. Events and windows under different grouping keys are
 treated independently. Outputs objects of type <a href="../../datamodel/WindowResult.html" title="class in com.hazelcast.jet.datamodel"><code>WindowResult</code></a>.
 <p>
 The vertex accepts input from one or more inbound edges. The type of
 items may be different on each edge. For each edge a separate key
 extracting function must be supplied and the aggregate operation must
 contain a separate accumulation function for each edge.
 <p>
 The functioning of this vertex is easiest to explain in terms of the
 <em>event interval</em>: the range <code>[timestamp, timestamp +
 sessionTimeout)</code>. Initially an event causes a new session window to be
 created, covering exactly the event interval. A following event under
 the same key belongs to this window iff its interval overlaps it. The
 window is extended to cover the entire interval of the new event. The
 event may happen to belong to two existing windows if its interval
 bridges the gap between them; in that case they are combined into one.
 <p>
 <i>Behavior on job restart</i><br>
 This processor saves its state to snapshot. After restart, it can
 continue accumulating where it left off.
 <p>
 After a restart in at-least-once mode, watermarks are allowed to go back
 in time. The processor evicts state based on watermarks it received. If
 it receives duplicate watermark, it might emit sessions with missing
 events, because they were already evicted. The sessions before and after
 snapshot might overlap, which they normally don't.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>K</code> - type of the item's grouping key</dd>
<dd><code>A</code> - type of the container of the accumulated value</dd>
<dd><code>R</code> - type of the session window's result value</dd>
<dt>Parameters:</dt>
<dd><code>sessionTimeout</code> - maximum gap between consecutive events in the same session window</dd>
<dd><code>timestampFns</code> - functions to extract the timestamp from the item</dd>
<dd><code>keyFns</code> - functions to extract the grouping key from the item</dd>
<dd><code>aggrOp</code> - the aggregate operation</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="insertWatermarksP(com.hazelcast.jet.core.EventTimePolicy)">
<h3>insertWatermarksP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">insertWatermarksP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../EventTimePolicy.html" title="class in com.hazelcast.jet.core">EventTimePolicy</a>&lt;? super T&gt;&nbsp;eventTimePolicy)</span></div>
<div class="block">Returns a supplier of processors for a vertex that inserts <a href="../Watermark.html" title="class in com.hazelcast.jet.core"><code>watermark items</code></a> into the stream. The
 value of the watermark is determined by the supplied <a href="../EventTimePolicy.html" title="class in com.hazelcast.jet.core"><code>EventTimePolicy</code></a> instance.
 <p>
 This processor also drops late items. It never allows an event which is
 late with regard to already emitted watermark to pass.
 <p>
 The processor saves value of the last emitted watermark to snapshot.
 Different instances of this processor can be at different watermark at
 snapshot time. After restart all instances will start at watermark of
 the most-behind instance before the restart.
 <p>
 This might sound as it could break the monotonicity requirement, but
 thanks to watermark coalescing, watermarks are only delivered for
 downstream processing after they have been received from <i>all</i>
 upstream processors. Another side effect of this is, that a late event,
 which was dropped before restart, is not considered late after restart.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - the type of the stream item</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapP(com.hazelcast.function.FunctionEx)">
<h3>mapP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">mapP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends R&gt;&nbsp;mapFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex which, for each received
 item, emits the result of applying the given mapping function to it. If
 the result is <code>null</code>, it emits nothing. Therefore this vertex can
 be used to implement filtering semantics as well.
 <p>
 This processor is stateless.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of received item</dd>
<dd><code>R</code> - type of emitted item</dd>
<dt>Parameters:</dt>
<dd><code>mapFn</code> - a stateless mapping function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterP(com.hazelcast.function.PredicateEx)">
<h3>filterP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">filterP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/PredicateEx.html" title="interface in com.hazelcast.function">PredicateEx</a>&lt;? super T&gt;&nbsp;filterFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that emits the same items
 it receives, but only those that pass the given predicate.
 <p>
 This processor is stateless.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of received item</dd>
<dt>Parameters:</dt>
<dd><code>filterFn</code> - a stateless predicate to test each received item against</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapP(com.hazelcast.function.FunctionEx)">
<h3>flatMapP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">flatMapP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;? extends R&gt;&gt;&nbsp;flatMapFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that applies the provided
 item-to-traverser mapping function to each received item and emits all
 the items from the resulting traverser. The traverser must be
 <em>null-terminated</em>.
 <p>
 This processor is stateless.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - received item type</dd>
<dd><code>R</code> - emitted item type</dd>
<dt>Parameters:</dt>
<dd><code>flatMapFn</code> - a stateless function that maps the received item
                 to a traverser over output items. It must not return
                 null traverser, but can return an <a href="../../Traversers.html#empty()">empty traverser</a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapStatefulP(long,com.hazelcast.function.FunctionEx,com.hazelcast.function.ToLongFunctionEx,java.util.function.Supplier,com.hazelcast.jet.function.TriFunction,com.hazelcast.jet.function.TriFunction)">
<h3>mapStatefulP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
S,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">mapStatefulP</span>&#8203;(<span class="parameters">long&nbsp;ttl,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;timestampFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" title="class or interface in java.util.function" class="external-link">Supplier</a>&lt;? extends S&gt;&nbsp;createFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super T,&#8203;? extends R&gt;&nbsp;statefulMapFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html" title="class or interface in javax.annotation" class="external-link">@Nullable</a>
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,&#8203;? extends R&gt;&nbsp;onEvictFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that performs a stateful
 mapping of its input. <code>createFn</code> returns the object that holds the
 state. The processor passes this object along with each input item to
 <code>mapFn</code>, which can update the object's state. For each grouping
 key there's a separate state object. The state object will be included
 in the state snapshot, so it survives job restarts. For this reason the
 object must be serializable. If the mapping function maps an item to
 <code>null</code>, it will have the effect of filtering out that item.
 <p>
 If the given <code>ttl</code> is greater than zero, the processor will
 consider the state object stale if its time-to-live has expired. The
 time-to-live refers to the event time as kept by the watermark: each
 time it processes an event, the processor compares the state object's
 timestamp with the current watermark. If it is less than <code>
 wm - ttl</code>, it discards the state object. Otherwise it updates the
 timestamp with the current watermark.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - type of the key</dd>
<dd><code>S</code> - type of the state object</dd>
<dd><code>R</code> - type of the mapping function's result</dd>
<dt>Parameters:</dt>
<dd><code>ttl</code> - state object's time to live</dd>
<dd><code>keyFn</code> - function to extract the key from an input item</dd>
<dd><code>createFn</code> - supplier of the state object</dd>
<dd><code>statefulMapFn</code> - the stateful mapping function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapStatefulP(long,com.hazelcast.function.FunctionEx,com.hazelcast.function.ToLongFunctionEx,java.util.function.Supplier,com.hazelcast.jet.function.TriFunction,com.hazelcast.jet.function.TriFunction)">
<h3>flatMapStatefulP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T,&#8203;
K,&#8203;
S,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">flatMapStatefulP</span>&#8203;(<span class="parameters">long&nbsp;ttl,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;? super T,&#8203;? extends K&gt;&nbsp;keyFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/ToLongFunctionEx.html" title="interface in com.hazelcast.function">ToLongFunctionEx</a>&lt;? super T&gt;&nbsp;timestampFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" title="class or interface in java.util.function" class="external-link">Supplier</a>&lt;? extends S&gt;&nbsp;createFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;statefulFlatMapFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html" title="class or interface in javax.annotation" class="external-link">@Nullable</a>
<a href="../../function/TriFunction.html" title="interface in com.hazelcast.jet.function">TriFunction</a>&lt;? super S,&#8203;? super K,&#8203;? super <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;onEvictFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that performs a stateful
 flat-mapping of its input. <code>createFn</code> returns the object that
 holds the state. The processor passes this object along with each input
 item to <code>mapFn</code>, which can update the object's state. For each
 grouping key there's a separate state object. The state object will be
 included in the state snapshot, so it survives job restarts. For this
 reason the object must be serializable.
 <p>
 If the given <code>ttl</code> is greater than zero, the processor will
 consider the state object stale if its time-to-live has expired. The
 time-to-live refers to the event time as kept by the watermark: each
 time it processes an event, the processor compares the state object's
 timestamp with the current watermark. If it is less than <code>
 wm - ttl</code>, it discards the state object. Otherwise it updates the
 timestamp with the current watermark.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - type of the input item</dd>
<dd><code>K</code> - type of the key</dd>
<dd><code>S</code> - type of the state object</dd>
<dd><code>R</code> - type of the mapping function's result</dd>
<dt>Parameters:</dt>
<dd><code>ttl</code> - state object's time to live</dd>
<dd><code>keyFn</code> - function to extract the key from an input item</dd>
<dd><code>createFn</code> - supplier of the state object</dd>
<dd><code>statefulFlatMapFn</code> - the stateful mapping function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)">
<h3>mapUsingServiceP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;C,&#8203;
S,&#8203;
T,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></span>&nbsp;<span class="member-name">mapUsingServiceP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;? extends R&gt;&nbsp;mapFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex which, for each received
 item, emits the result of applying the given mapping function to it. The
 mapping function receives another parameter, the service object which
 Jet will create using the supplied <code>serviceFactory</code>.
 <p>
 If the mapping result is <code>null</code>, the vertex emits nothing.
 Therefore it can be used to implement filtering semantics as well.
 <p>
 Unlike <a href="#mapStatefulP(long,com.hazelcast.function.FunctionEx,com.hazelcast.function.ToLongFunctionEx,java.util.function.Supplier,com.hazelcast.jet.function.TriFunction,com.hazelcast.jet.function.TriFunction)"><code>mapStatefulP(long, com.hazelcast.function.FunctionEx&lt;? super T, ? extends K&gt;, com.hazelcast.function.ToLongFunctionEx&lt;? super T&gt;, java.util.function.Supplier&lt;? extends S&gt;, com.hazelcast.jet.function.TriFunction&lt;? super S, ? super K, ? super T, ? extends R&gt;, com.hazelcast.jet.function.TriFunction&lt;? super S, ? super K, ? super java.lang.Long, ? extends R&gt;)</code></a> (with the "<code>Keyed</code>" part),
 this method creates one service object per processor.
 <p>
 While it's allowed to store some local state in the service object, it
 won't be saved to the snapshot and will misbehave in a fault-tolerant
 stream processing job.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>C</code> - type of context object</dd>
<dd><code>S</code> - type of service object</dd>
<dd><code>T</code> - type of received item</dd>
<dd><code>R</code> - type of emitted item</dd>
<dt>Parameters:</dt>
<dd><code>serviceFactory</code> - the service factory</dd>
<dd><code>mapFn</code> - a stateless mapping function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapUsingServiceAsyncP(com.hazelcast.jet.pipeline.ServiceFactory,int,boolean,com.hazelcast.function.FunctionEx,com.hazelcast.function.BiFunctionEx)">
<h3>mapUsingServiceAsyncP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;C,&#8203;
S,&#8203;
T,&#8203;
K,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></span>&nbsp;<span class="member-name">mapUsingServiceAsyncP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
int&nbsp;maxConcurrentOps,
boolean&nbsp;preserveOrder,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/FunctionEx.html" title="interface in com.hazelcast.function">FunctionEx</a>&lt;T,&#8203;K&gt;&nbsp;extractKeyFn,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" title="class or interface in java.util.concurrent" class="external-link">CompletableFuture</a>&lt;R&gt;&gt;&nbsp;mapAsyncFn)</span></div>
<div class="block">Asynchronous version of <a href="#mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)"><code>mapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory&lt;C, S&gt;, com.hazelcast.function.BiFunctionEx&lt;? super S, ? super T, ? extends R&gt;)</code></a>: the <code>
 mapAsyncFn</code> returns a <code>CompletableFuture&lt;R&gt;</code> instead of just
 <code>R</code>.
 <p>
 The function can return a null future and the future can return a null
 result: in both cases it will act just like a filter.
 <p>
 The <code>extractKeyFn</code> is used to extract keys under which to save
 in-flight items to the snapshot. If the input to this processor is over
 a partitioned edge, you should use the same key. If it's a round-robin
 edge, you can use any key, for example <code>Object::hashCode</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>C</code> - type of context object</dd>
<dd><code>S</code> - type of service object</dd>
<dd><code>T</code> - type of received item</dd>
<dd><code>K</code> - type of key</dd>
<dd><code>R</code> - type of result item</dd>
<dt>Parameters:</dt>
<dd><code>serviceFactory</code> - the service factory</dd>
<dd><code>maxConcurrentOps</code> - maximum number of concurrent async operations per processor</dd>
<dd><code>preserveOrder</code> - whether the async responses are ordered or not</dd>
<dd><code>extractKeyFn</code> - a function to extract snapshot keys. Used only if preserveOrder==false</dd>
<dd><code>mapAsyncFn</code> - a stateless mapping function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="filterUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiPredicateEx)">
<h3>filterUsingServiceP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;C,&#8203;
S,&#8203;
T&gt;</span>&nbsp;<span class="return-type"><a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></span>&nbsp;<span class="member-name">filterUsingServiceP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiPredicateEx.html" title="interface in com.hazelcast.function">BiPredicateEx</a>&lt;? super S,&#8203;? super T&gt;&nbsp;filterFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that emits the same items
 it receives, but only those that pass the given predicate. The predicate
 function receives another parameter, the service object which Jet will
 create using the supplied <code>serviceFactory</code>.
 <p>
 While it's allowed to store some local state in the service object, it
 won't be saved to the snapshot and will misbehave in a fault-tolerant
 stream processing job.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>C</code> - type of context object</dd>
<dd><code>S</code> - type of service object</dd>
<dd><code>T</code> - type of received item</dd>
<dt>Parameters:</dt>
<dd><code>serviceFactory</code> - the service factory</dd>
<dd><code>filterFn</code> - a stateless predicate to test each received item against</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapUsingServiceP(com.hazelcast.jet.pipeline.ServiceFactory,com.hazelcast.function.BiFunctionEx)">
<h3>flatMapUsingServiceP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;C,&#8203;
S,&#8203;
T,&#8203;
R&gt;</span>&nbsp;<span class="return-type"><a href="../ProcessorSupplier.html" title="interface in com.hazelcast.jet.core">ProcessorSupplier</a></span>&nbsp;<span class="member-name">flatMapUsingServiceP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../pipeline/ServiceFactory.html" title="class in com.hazelcast.jet.pipeline">ServiceFactory</a>&lt;C,&#8203;S&gt;&nbsp;serviceFactory,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="../../../function/BiFunctionEx.html" title="interface in com.hazelcast.function">BiFunctionEx</a>&lt;? super S,&#8203;? super T,&#8203;? extends <a href="../../Traverser.html" title="interface in com.hazelcast.jet">Traverser</a>&lt;R&gt;&gt;&nbsp;flatMapFn)</span></div>
<div class="block">Returns a supplier of processors for a vertex that applies the provided
 item-to-traverser mapping function to each received item and emits all
 the items from the resulting traverser. The traverser must be
 <em>null-terminated</em>. The mapping function receives another parameter,
 the service object which Jet will create using the supplied <code>
 serviceFactory</code>.
 <p>
 While it's allowed to store some local state in the service object, it
 won't be saved to the snapshot and will misbehave in a fault-tolerant
 stream processing job.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>C</code> - type of context object</dd>
<dd><code>S</code> - type of service object</dd>
<dd><code>T</code> - type of input item</dd>
<dd><code>R</code> - type of result item</dd>
<dt>Parameters:</dt>
<dd><code>serviceFactory</code> - the service factory</dd>
<dd><code>flatMapFn</code> - a stateless function that maps the received item to a traverser over
                  the output items</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sortP(java.util.Comparator)">
<h3>sortP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">sortP</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" title="class or interface in java.util" class="external-link">Comparator</a>&lt;T&gt;&nbsp;comparator)</span></div>
<div class="block">Returns a supplier of processors for a vertex that sorts its input using
 a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" title="class or interface in java.util" class="external-link"><code>PriorityQueue</code></a> and emits it in the <code>complete</code> phase.
 <p>
 The output edge of this vertex should be <a href="../Edge.html#distributed()"><code>distributed</code></a> <a href="../Edge.html#ordered(com.hazelcast.function.ComparatorEx)"><code>monotonicOrder</code></a> <a href="../Edge.html#allToOne(java.lang.Object)"><code>allToOne</code></a> so it preserves the ordering when merging
 the data from all upstream processors.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>4.3</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="noopP()">
<h3>noopP</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="../../../function/SupplierEx.html" title="interface in com.hazelcast.function">SupplierEx</a>&lt;<a href="../Processor.html" title="interface in com.hazelcast.jet.core">Processor</a>&gt;</span>&nbsp;<span class="member-name">noopP</span>()</div>
<div class="block">Returns a supplier of a processor that swallows all its normal input (if
 any), does nothing with it, forwards the watermarks, produces no output
 and completes immediately. It also swallows any restored snapshot data.</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Processors.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
