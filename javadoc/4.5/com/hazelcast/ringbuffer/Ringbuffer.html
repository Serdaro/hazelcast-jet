<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Tue Apr 20 14:42:57 CEST 2021 -->
<title>Ringbuffer (hazelcast-jet-distribution 4.5 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-04-20">
<meta name="description" content="declaration: package: com.hazelcast.ringbuffer, interface: Ringbuffer">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Ringbuffer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.ringbuffer</a></div>
<h1 title="Interface Ringbuffer" class="title">Interface Ringbuffer&lt;E&gt;</h1>
</div>
<section class="description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>E</code> - The type of the elements that the Ringbuffer contains</dd>
</dl>
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="type-name-label">Ringbuffer&lt;E&gt;</span>
extends <a href="../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></pre>
<div class="block">A Ringbuffer is a data structure where the content is stored in a ring-like
 structure. A ringbuffer has a fixed capacity so it won't grow beyond
 that capacity and endanger the stability of the system. If that capacity
 is exceeded, the oldest item in the ringbuffer is overwritten.
 <p>
 The ringbuffer has 2 always incrementing sequences:
 <ol>
 <li>
 <a href="#tailSequence()"><code>tailSequence()</code></a>: this is the side where the youngest item is found.
 So the tail is the side of the ringbuffer where items are added to.
 </li>
 <li>
 <a href="#headSequence()"><code>headSequence()</code></a>: this is the side where the oldest items are found.
 So the head is the side where items get discarded.
 </li>
 </ol>
 The items in the ringbuffer can be found by a sequence that is in between
 (inclusive) the head and tail sequence.
 <p>
 If data is read from a ringbuffer with a sequence that is smaller than the
 headSequence, it means that the data is not available anymore and a
 <a href="StaleSequenceException.html" title="class in com.hazelcast.ringbuffer"><code>StaleSequenceException</code></a> is thrown.
 <p>
 A Ringbuffer currently is a replicated, but not partitioned data structure.
 So all data is stored in a single partition, similarly to the <a href="../collection/IQueue.html" title="interface in com.hazelcast.collection"><code>IQueue</code></a> implementation.
 <p>
 A Ringbuffer can be used in a way similar to the IQueue, but one of the key
 differences is that a <code>queue.take</code> is destructive, meaning that only 1
 thread is able to take an item. A <code>ringbuffer.read</code> is not
 destructive, so you can have multiple threads reading the same item multiple
 times.
 <p>
 The Ringbuffer is the backing data structure for the reliable
 <a href="../topic/ITopic.html" title="interface in com.hazelcast.topic"><code>ITopic</code></a> implementation. See
 <a href="../config/ReliableTopicConfig.html" title="class in com.hazelcast.config"><code>ReliableTopicConfig</code></a>.
 <p>
 A Ringbuffer can be configured to be backed by a
 <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a>. All write methods will delegate
 to the store to persist the items, while reader methods will try to read
 items from the store if not found in the in-memory Ringbuffer.
 <p>
 When a Ringbuffer is constructed with a backing store, head and tail
 sequences are set to the following
 <ul>
 <li><code>tailSequence</code>: <code>lastStoreSequence</code></li>
 <li><code>headSequence</code>: <code>lastStoreSequence</code> + 1</li>
 </ul>
 where <code>lastStoreSequence</code> is the sequence of the previously last
 stored item.
 <p>
 Supports split brain protection <a href="../config/SplitBrainProtectionConfig.html" title="class in com.hazelcast.config"><code>SplitBrainProtectionConfig</code></a> since 3.10 in
 cluster versions 3.10 and higher.
 <p>
 <b>Asynchronous methods</b>
 <p>
 Asynchronous methods return a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link"><code>CompletionStage</code></a> that can be used to
 chain further computation stages. Alternatively, a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" title="class or interface in java.util.concurrent" class="external-link"><code>CompletableFuture</code></a>
 can be obtained via <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html#toCompletableFuture()" title="class or interface in java.util.concurrent" class="external-link"><code>CompletionStage.toCompletableFuture()</code></a> to wait
 for the operation to complete in a blocking way.
 <p>
 Actions supplied for dependent completions of default non-async methods and async methods
 without an explicit <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html" title="class or interface in java.util.concurrent" class="external-link"><code>Executor</code></a> argument are performed
 by the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool()" title="class or interface in java.util.concurrent" class="external-link"><code>ForkJoinPool.commonPool()</code></a> (unless it does not
 support a parallelism level of at least 2, in which case a new <code>Thread</code> is
 created per task).</div>
<dl class="notes">
<dt>Since:</dt>
<dd>3.5</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#add(E)">add</a></span>&#8203;(<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&nbsp;item)</code></th>
<td class="col-last">
<div class="block">Adds an item to the tail of the Ringbuffer.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addAllAsync(java.util.Collection,com.hazelcast.ringbuffer.OverflowPolicy)">addAllAsync</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" title="class or interface in java.util" class="external-link">Collection</a>&lt;? extends <a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&gt;&nbsp;collection,
<a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer">OverflowPolicy</a>&nbsp;overflowPolicy)</code></th>
<td class="col-last">
<div class="block">Adds all the items of a collection to the tail of the Ringbuffer.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addAsync(E,com.hazelcast.ringbuffer.OverflowPolicy)">addAsync</a></span>&#8203;(<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&nbsp;item,
<a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer">OverflowPolicy</a>&nbsp;overflowPolicy)</code></th>
<td class="col-last">
<div class="block">Asynchronously writes an item with a configurable <a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer"><code>OverflowPolicy</code></a>.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#capacity()">capacity</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the capacity of this Ringbuffer.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#headSequence()">headSequence</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the sequence of the head.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="ReadResultSet.html" title="interface in com.hazelcast.ringbuffer">ReadResultSet</a>&lt;<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&gt;&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#readManyAsync(long,int,int,com.hazelcast.core.IFunction)">readManyAsync</a></span>&#8203;(long&nbsp;startSequence,
int&nbsp;minCount,
int&nbsp;maxCount,
<a href="../core/IFunction.html" title="interface in com.hazelcast.core">IFunction</a>&lt;<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html" title="class or interface in java.lang" class="external-link">Boolean</a>&gt;&nbsp;filter)</code></th>
<td class="col-last">
<div class="block">Reads a batch of items from the Ringbuffer.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code><a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#readOne(long)">readOne</a></span>&#8203;(long&nbsp;sequence)</code></th>
<td class="col-last">
<div class="block">Reads one item from the Ringbuffer.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#remainingCapacity()">remainingCapacity</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the remaining capacity of the ringbuffer.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#size()">size</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns number of items in the Ringbuffer.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#tailSequence()">tailSequence</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the sequence of the tail.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.com.hazelcast.core.DistributedObject">Methods inherited from interface&nbsp;com.hazelcast.core.<a href="../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></h3>
<code><a href="../core/DistributedObject.html#destroy()">destroy</a>, <a href="../core/DistributedObject.html#getDestroyContextForTenant()">getDestroyContextForTenant</a>, <a href="../core/DistributedObject.html#getName()">getName</a>, <a href="../core/DistributedObject.html#getPartitionKey()">getPartitionKey</a>, <a href="../core/DistributedObject.html#getServiceName()">getServiceName</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="capacity()">
<h3>capacity</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">capacity</span>()</div>
<div class="block">Returns the capacity of this Ringbuffer.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the capacity.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="size()">
<h3>size</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">size</span>()</div>
<div class="block">Returns number of items in the Ringbuffer.
 <p>
 If no TTL is set, the size will always be equal to capacity after the
 head completed the first loop around the ring. This is because no items
 are being removed.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the size.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="tailSequence()">
<h3>tailSequence</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">tailSequence</span>()</div>
<div class="block">Returns the sequence of the tail. The tail is the side of the Ringbuffer
 where the items are added to.
 <p>
 The initial value of the tail is -1 if the Ringbuffer is not backed by a
 store, otherwise tail sequence will be set to the sequence of the
 previously last stored item.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the sequence of the tail.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="headSequence()">
<h3>headSequence</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">headSequence</span>()</div>
<div class="block">Returns the sequence of the head. The head is the side of the Ringbuffer
 where the oldest items in the Ringbuffer are found.
 <p>
 If the RingBuffer is empty, the head will be one more than the tail.
 <p>
 The initial value of the head is 0 if the Ringbuffer is not backed by a
 store, otherwise head sequence will be set to the sequence of the
 previously last stored item + 1. In both cases head sequence is 1 more
 than the tail sequence.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the sequence of the head.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="remainingCapacity()">
<h3>remainingCapacity</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">remainingCapacity</span>()</div>
<div class="block">Returns the remaining capacity of the ringbuffer. If TTL is enabled,
 then the returned capacity is equal to the total capacity of the
 ringbuffer minus the number of used slots in the ringbuffer which have
 not yet been marked as expired and cleaned up. Keep in mind that some
 slots could have expired items that have not yet been cleaned up and
 that the returned value could be stale as soon as it is returned.
 <p>
 If TTL is disabled, the remaining capacity is equal to the total
 ringbuffer capacity.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the remaining capacity</dd>
<dt>See Also:</dt>
<dd><a href="../config/RingbufferConfig.html#DEFAULT_TTL_SECONDS"><code>RingbufferConfig.DEFAULT_TTL_SECONDS</code></a>, 
<a href="#capacity()"><code>capacity()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(E)">
<h3 id="add(java.lang.Object)">add</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">add</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&nbsp;item)</span></div>
<div class="block">Adds an item to the tail of the Ringbuffer. If there is no space in the
 Ringbuffer, the add will overwrite the oldest item in the ringbuffer no
 matter what the TTL is. For more control on this behavior, check the
 <a href="#addAsync(E,com.hazelcast.ringbuffer.OverflowPolicy)"><code>addAsync(Object, OverflowPolicy)</code></a> and the <a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer"><code>OverflowPolicy</code></a>.
 <p>
 The returned value is the sequence of the added item. Using this sequence
 you can read the added item.

 <h3>Using the sequence as ID</h3>
 This sequence will always be unique for this Ringbuffer instance so it
 can be used as a unique ID generator if you are publishing items on this
 Ringbuffer. However you need to take care of correctly determining an
 initial ID when any node uses the Ringbuffer for the first time. The
 most reliable way to do that is to write a dummy item into the Ringbuffer
 and use the returned sequence as initial ID. On the reading side, this
 dummy item should be discard. Please keep in mind that this ID is not the
 sequence of the item you are about to publish but from a previously
 published item. So it can't be used to find that item.
 <p>
 If the Ringbuffer is backed by a <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a>,
 the item gets persisted by the underlying store via
 <a href="RingbufferStore.html#store(long,T)"><code>RingbufferStore.store(long, Object)</code></a>. Note that
 in case an exception is thrown by the store, it prevents the item from being
 added to the Ringbuffer, keeping the store, primary and the backups
 consistent.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>item</code> - the item to add.</dd>
<dt>Returns:</dt>
<dd>the sequence of the added item.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" title="class or interface in java.lang" class="external-link">NullPointerException</a></code> - if item is null.</dd>
<dt>See Also:</dt>
<dd><a href="#addAsync(E,com.hazelcast.ringbuffer.OverflowPolicy)"><code>addAsync(Object, OverflowPolicy)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addAsync(E,com.hazelcast.ringbuffer.OverflowPolicy)">
<h3 id="addAsync(java.lang.Object,com.hazelcast.ringbuffer.OverflowPolicy)">addAsync</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="member-name">addAsync</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&nbsp;item,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer">OverflowPolicy</a>&nbsp;overflowPolicy)</span></div>
<div class="block">Asynchronously writes an item with a configurable <a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer"><code>OverflowPolicy</code></a>.
 <p>
 If there is space in the Ringbuffer, the call will return the sequence
 of the written item. If there is no space, it depends on the overflow
 policy what happens:
 <ol>
 <li><a href="OverflowPolicy.html#OVERWRITE"><code>OverflowPolicy.OVERWRITE</code></a>: we just overwrite the oldest item
 in the Ringbuffer and we violate the TTL</li>
 <li><a href="OverflowPolicy.html#FAIL"><code>OverflowPolicy.FAIL</code></a>: we return -1 </li>
 </ol>
 <p>
 The reason that FAIL exist is to give the opportunity to obey the TTL.
 If blocking behavior is required, this can be implemented using retrying
 in combination with an exponential backoff. Example:
 <pre><code>
 long sleepMs = 100;
 for (; ; ) {
   long result = ringbuffer.addAsync(item, FAIL).toCompletableFuture().get();
   if (result != -1) {
     break;
   }
   TimeUnit.MILLISECONDS.sleep(sleepMs);
   sleepMs = min(5000, sleepMs * 2);
 }
 </code></pre>
 <p>
 If the Ringbuffer is backed by a <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a>,
 the item gets persisted by the underlying store via
 <a href="RingbufferStore.html#store(long,T)"><code>RingbufferStore.store(long, Object)</code></a>. Note
 that in case an exception is thrown by the store, it prevents the item
 from being added to the Ringbuffer, keeping the store, primary and the
 backups consistent.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>item</code> - the item to add</dd>
<dd><code>overflowPolicy</code> - the OverflowPolicy to use.</dd>
<dt>Returns:</dt>
<dd>the sequenceId of the added item, or -1 if the add failed.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" title="class or interface in java.lang" class="external-link">NullPointerException</a></code> - if item or overflowPolicy is null.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="readOne(long)">
<h3>readOne</h3>
<div class="member-signature"><span class="return-type"><a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a></span>&nbsp;<span class="member-name">readOne</span>&#8203;(<span class="parameters">long&nbsp;sequence)</span>
   throws <span class="exceptions"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html" title="class or interface in java.lang" class="external-link">InterruptedException</a></span></div>
<div class="block">Reads one item from the Ringbuffer.
 <p>
 If the sequence is one beyond the current tail, this call blocks until
 an item is added. This means that the ringbuffer can be processed using
 the following idiom:
 <pre><code>
 Ringbuffer&lt;String&gt; ringbuffer = hz.getRingbuffer("rb");
 long seq = ringbuffer.headSequence();
 while(true){
   String item = ringbuffer.readOne(seq);
   seq++;
   ... process item
 }
 </code></pre>
 <p>
 This method is not destructive unlike e.g. a <a href="../collection/BaseQueue.html#take()"><code>BaseQueue.take()</code></a>.
 So the same item can be read by multiple readers or it can be read
 multiple times by the same reader.
 <p>
 Currently it isn't possible to control how long this call is going to
 block. In the future we could add e.g.
 <code>tryReadOne(long sequence, long timeout, TimeUnit unit)</code>.
 <p>
 If the item is not in the Ringbuffer an attempt is made to read it from
 the underlying <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a> via
 <a href="RingbufferStore.html#load(long)"><code>RingbufferStore.load(long)</code></a> if store is
 configured for the Ringbuffer. These cases may increase the execution time
 significantly depending on the implementation of the store. Note that
 exceptions thrown by the store are propagated to the caller.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sequence</code> - the sequence of the item to read.</dd>
<dt>Returns:</dt>
<dd>the read item</dd>
<dt>Throws:</dt>
<dd><code><a href="StaleSequenceException.html" title="class in com.hazelcast.ringbuffer">StaleSequenceException</a></code> - if the sequence is smaller than
                                  <a href="#headSequence()"><code>headSequence()</code></a>. Because a
                                  Ringbuffer won't store all event
                                  indefinitely, it can be that the data
                                  for the given sequence doesn't exist
                                  anymore and the
                                  <a href="StaleSequenceException.html" title="class in com.hazelcast.ringbuffer"><code>StaleSequenceException</code></a> is thrown.
                                  It is up to the caller to deal with
                                  this particular situation, e.g. throw an
                                  Exception or restart from the last known
                                  head. That is why the
                                  StaleSequenceException contains the last
                                  known head.</dd>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang" class="external-link">IllegalArgumentException</a></code> - if sequence is smaller than 0 or larger than <a href="#tailSequence()"><code>tailSequence()</code></a>+1.</dd>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html" title="class or interface in java.lang" class="external-link">InterruptedException</a></code> - if the call is interrupted while blocking.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addAllAsync(java.util.Collection,com.hazelcast.ringbuffer.OverflowPolicy)">
<h3>addAllAsync</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" title="class or interface in java.lang" class="external-link">Long</a>&gt;</span>&nbsp;<span class="member-name">addAllAsync</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" title="class or interface in java.util" class="external-link">Collection</a>&lt;? extends <a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&gt;&nbsp;collection,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="OverflowPolicy.html" title="enum in com.hazelcast.ringbuffer">OverflowPolicy</a>&nbsp;overflowPolicy)</span></div>
<div class="block">Adds all the items of a collection to the tail of the Ringbuffer.
 <p>
 An addAll is likely to outperform multiple calls to <a href="#add(E)"><code>add(Object)</code></a>
 due to better io utilization and a reduced number of executed operations.
 If the batch is empty, the call is ignored.
 <p>
 When the collection is not empty, the content is copied into a different
 data-structure. This means that:
 <ol>
 <li>after this call completes, the collection can be re-used.</li>
 <li>the collection doesn't need to be serializable</li>
 </ol>
 <p>
 If the collection is larger than the capacity of the Ringbuffer, then
 the items that were written first will be overwritten. Therefore this
 call will not block.
 <p>
 The items are inserted in the order of the Iterator of the collection.
 If an addAll is executed concurrently with an add or addAll, no
 guarantee is given that items are contiguous.
 <p>
 The result of the future contains the sequenceId of the last written
 item.
 <p>
 If the Ringbuffer is backed by a <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a>,
 the items are persisted by the underlying store via
 <a href="RingbufferStore.html#storeAll(long,T%5B%5D)"><code>RingbufferStore.storeAll(long, Object[])</code></a>.
 Note that in case an exception is thrown by the store, it makes the
 Ringbuffer not adding any of the items to the primary and the backups.
 Keeping the store consistent with the primary and the backups is the
 responsibility of the store.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>collection</code> - the batch of items to add.</dd>
<dt>Returns:</dt>
<dd>the CompletionStage to synchronize on completion.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" title="class or interface in java.lang" class="external-link">NullPointerException</a></code> - if batch is null, or if an item in this
                                  batch is null or if overflowPolicy is null</dd>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang" class="external-link">IllegalArgumentException</a></code> - if collection is empty</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="readManyAsync(long,int,int,com.hazelcast.core.IFunction)">
<h3>readManyAsync</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" title="class or interface in java.util.concurrent" class="external-link">CompletionStage</a>&lt;<a href="ReadResultSet.html" title="interface in com.hazelcast.ringbuffer">ReadResultSet</a>&lt;<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>&gt;&gt;</span>&nbsp;<span class="member-name">readManyAsync</span>&#8203;(<span class="parameters">long&nbsp;startSequence,
int&nbsp;minCount,
int&nbsp;maxCount,
<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nullable.html" title="class or interface in javax.annotation" class="external-link">@Nullable</a>
<a href="../core/IFunction.html" title="interface in com.hazelcast.core">IFunction</a>&lt;<a href="Ringbuffer.html" title="type parameter in Ringbuffer">E</a>,&#8203;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html" title="class or interface in java.lang" class="external-link">Boolean</a>&gt;&nbsp;filter)</span></div>
<div class="block">Reads a batch of items from the Ringbuffer. If the number of available
 items after the first read item is smaller than the <code>maxCount</code>,
 these items are returned. So it could be the number of items read is
 smaller than the <code>maxCount</code>.
 <p>
 If there are less items available than <code>minCount</code>, then this call
 blocks.
 <p>
 <b>Warning:</b>
 <p>
 These blocking calls consume server memory and if there are many calls,
 it can be possible to see leaking memory or OOME.
 <p>
 Reading a batch of items is likely to perform better because less
 overhead is involved.
 <p>
 A filter can be provided to only select items that need to be read. If the
 filter is null, all items are read. If the filter is not null, only items
 where the filter function returns true are returned. Using filters is a
 good way to prevent getting items that are of no value to the receiver.
 This reduces the amount of IO and the number of operations being executed,
 and can result in a significant performance improvement.
 <p>
 For each item not available in the Ringbuffer an attempt is made to read
 it from the underlying <a href="RingbufferStore.html" title="interface in com.hazelcast.ringbuffer"><code>RingbufferStore</code></a> via
 multiple invocations of <a href="RingbufferStore.html#load(long)"><code>RingbufferStore.load(long)</code></a>,
 if store is configured for the Ringbuffer. These cases may increase the
 execution time significantly depending on the implementation of the store.
 Note that exceptions thrown by the store are propagated to the caller.
 <p>
 If the startSequence is smaller than the smallest sequence still available
 in the Ringbuffer (<a href="#headSequence()"><code>headSequence()</code></a>, then the smallest available
 sequence will be used as the start sequence and the minimum/maximum
 number of items will be attempted to be read from there on.
 <p>
 If the startSequence is bigger than the last available sequence in the
 Ringbuffer (<a href="#tailSequence()"><code>tailSequence()</code></a>), then the last available sequence
 plus one will be used as the start sequence and the call will block
 until further items become available and it can read at least the
 minimum number of items.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>startSequence</code> - the startSequence of the first item to read.</dd>
<dd><code>minCount</code> - the minimum number of items to read.</dd>
<dd><code>maxCount</code> - the maximum number of items to read.</dd>
<dd><code>filter</code> - the filter. Filter is allowed to be null, indicating
                      there is no filter.</dd>
<dt>Returns:</dt>
<dd>a future containing the items read.</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang" class="external-link">IllegalArgumentException</a></code> - if startSequence is smaller than 0
                                  or if minCount smaller than 0
                                  or if minCount larger than maxCount,
                                  or if maxCount larger than the capacity of the ringbuffer
                                  or if maxCount larger than 1000 (to prevent overload)</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Ringbuffer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
