<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Tue Apr 20 14:42:57 CEST 2021 -->
<title>CPSubsystem (hazelcast-jet-distribution 4.5 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-04-20">
<meta name="description" content="declaration: package: com.hazelcast.cp, interface: CPSubsystem">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/CPSubsystem.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.cp</a></div>
<h1 title="Interface CPSubsystem" class="title">Interface CPSubsystem</h1>
</div>
<section class="description">
<hr>
<pre>public interface <span class="type-name-label">CPSubsystem</span></pre>
<div class="block">CP Subsystem is a component of Hazelcast that builds a strongly consistent
 layer for a set of distributed data structures. Its APIs can be used for
 implementing distributed coordination use cases, such as leader election,
 distributed locking, synchronization, and metadata management.
 It is accessed via <a href="../core/HazelcastInstance.html#getCPSubsystem()"><code>HazelcastInstance.getCPSubsystem()</code></a>. Its data
 structures are CP with respect to the CAP principle, i.e., they always
 maintain linearizability and prefer consistency over availability during
 network partitions. Besides network partitions, CP Subsystem withstands
 server and client failures.
 <p>
 Currently, CP Subsystem contains only the implementations of Hazelcast's
 concurrency APIs. Since these APIs do not maintain large states, all members
 of a Hazelcast cluster do not necessarily take part in CP Subsystem.
 The number of Hazelcast members that takes part in CP Subsystem is specified
 with <a href="../config/cp/CPSubsystemConfig.html#setCPMemberCount(int)"><code>CPSubsystemConfig.setCPMemberCount(int)</code></a>. Say that it is
 configured as N. Then, when a Hazelcast cluster starts, the first N members
 form CP Subsystem. These members are called <a href="CPMember.html" title="interface in com.hazelcast.cp"><code>CPMember</code></a>s, and they can
 also contain data for other regular -AP- Hazelcast data structures, such as
 <a href="../map/IMap.html" title="interface in com.hazelcast.map"><code>IMap</code></a>, <a href="../collection/ISet.html" title="interface in com.hazelcast.collection"><code>ISet</code></a>.
 <p>
 Data structures in CP Subsystem run in <a href="CPGroup.html" title="interface in com.hazelcast.cp"><code>CPGroup</code></a>s. Each CP group
 elects its own Raft leader and runs the Raft consensus algorithm
 independently. CP Subsystem runs 2 CP groups by default. The first one is
 the METADATA CP group which is an internal CP group responsible for managing
 CP members and CP groups. It is initialized during cluster startup if CP
 Subsystem is enabled via <a href="../config/cp/CPSubsystemConfig.html#setCPMemberCount(int)"><code>CPSubsystemConfig.setCPMemberCount(int)</code></a>.
 The second CP group is the DEFAULT CP group, whose name is given in
 <a href="CPGroup.html#DEFAULT_GROUP_NAME"><code>CPGroup.DEFAULT_GROUP_NAME</code></a>. If a group name is not specified while
 creating a CP data structure proxy, that data structure is mapped to
 the DEFAULT CP group. For instance, when a CP <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance
 is created via <code>.getAtomicLong("myAtomicLong")</code>, it is initialized on
 the DEFAULT CP group. Besides these 2 pre-defined CP groups, custom CP
 groups can be created at run-time while fetching CP data structure proxies.
 For instance, if a CP <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> is created by calling
 <code>.getAtomicLong("myAtomicLong@myGroup")</code>, first a new CP group is
 created with the name "myGroup" and then "myAtomicLong" is initialized on
 this custom CP group.
 <p>
 This design implies that each CP member can participate to more than one CP
 group. CP Subsystem runs a periodic background task to ensure that each CP
 member performs the Raft leadership role for roughly equal number of CP
 groups. For instance, if there are 3 CP members and 3 CP groups, each CP
 member becomes Raft leader for only 1 CP group. If one more CP group is
 created, then one of the CP members gets the Raft leader role for 2 CP
 groups. This is done because Raft is a leader-based consensus algorithm.
 A Raft leader node becomes responsible for handling incoming requests from
 callers and replicating them to follower nodes. If a CP member gets the Raft
 leadership role for too many CP groups compared to other CP members, it can
 turn into a bottleneck.
 <p>
 CP member count of CP groups are specified via
 <a href="../config/cp/CPSubsystemConfig.html#setGroupSize(int)"><code>CPSubsystemConfig.setGroupSize(int)</code></a>. Please note that this
 configuration does not have to be same with the CP member count. Namely,
 number of CP members in CP Subsystem can be larger than the configured
 CP group size. CP groups usually consist of an odd number of CP members
 between 3 and 7. Operations are committed &amp; executed only after they are
 successfully replicated to the majority of CP members in a CP group.
 An odd number of CP members is more advantageous to an even number because
 of the quorum or majority calculations. For a CP group of N members,
 majority is calculated as N / 2 + 1. For instance, in a CP group of 5 CP
 members, operations are committed when they are replicated to at least 3 CP
 members. This CP group can tolerate failure of 2 CP members and remain
 available. However, if we run a CP group with 6 CP members, it can still
 tolerate failure of 2 CP members because majority of 6 is 4. Therefore,
 it does not improve the degree of fault tolerance compared to 5 CP members.
 <p>
 CP Subsystem achieves horizontal scalability thanks to all of
 the aforementioned CP group management capabilities. You can scale out
 the throughput and memory capacity by distributing your CP data structures
 to multiple CP groups (i.e., manual partitioning / sharding) and
 distributing those CP groups over CP members (i.e., choosing a CP group size
 that is smaller than the CP member count configuration). Nevertheless,
 the current set of CP data structures have quite low memory overheads.
 Moreover, related to the Raft consensus algorithm, each CP group makes use
 of internal heartbeat RPCs to maintain authority of the Raft leader and help
 lagging CP group members to make progress. Last, the new CP lock and
 semaphore implementations rely on a brand new session mechanism. In a
 nutshell, a Hazelcast server or a client starts a new session on the
 corresponding CP group when it makes its very first lock or semaphore
 acquire request, and then periodically commits session heartbeats to this CP
 group in order to indicate its liveliness. It means that if CP locks and
 semaphores are distributed to multiple CP groups, there will be a session
 management overhead on each CP group. Please see <a href="session/CPSession.html" title="interface in com.hazelcast.cp.session"><code>CPSession</code></a> for more
 details. For these reasons, we recommend developers to use a minimal number
 of CP groups. For most use cases, the DEFAULT CP group should be sufficient
 to maintain all CP data structure instances. Custom CP groups is recommended
 only when you benchmark your deployment and decide that performance of
 the DEFAULT CP group is not sufficient for your workload.
 <p>
 CP Subsystem runs a discovery process on cluster startup. When CP Subsystem
 is enabled by setting a positive value to
 <a href="../config/cp/CPSubsystemConfig.html#setCPMemberCount(int)"><code>CPSubsystemConfig.setCPMemberCount(int)</code></a>, say N, the first N members
 in the Hazelcast cluster member list initiate this discovery process. Other
 Hazelcast members skip this step. The CP discovery process runs out of
 the box on top of Hazelcast's cluster member list without requiring any
 custom configuration for different environments. It is completed when each
 one of the first N Hazelcast members initializes its local CP member list
 and commits it to the METADATA CP group. <strong>A soon-to-be CP member
 terminates itself if any of the following conditions occur before the CP
 discovery process is completed:</strong>
 <ul>
 <li>Any Hazelcast member leaves the cluster,</li>
 <li>The local Hazelcast member commits a CP member list which is different
 from other members' committed CP member lists,</li>
 <li>The local Hazelcast member fails to commit its discovered CP member list
 for any reason.</li>
 </ul>
 <p>
 <strong>The CP data structure proxies differ from the other Hazelcast data
 structure proxies in two aspects. First, an internal commit is performed on
 the METADATA CP group every time you fetch a proxy from this interface.
 Hence, callers should cache returned proxy objects. Second, if you call
 <a href="../core/DistributedObject.html#destroy()"><code>DistributedObject.destroy()</code></a> on a CP data structure proxy, that data
 structure is terminated on the underlying CP group and cannot be
 reinitialized until the CP group is force-destroyed via
 <a href="CPSubsystemManagementService.html#forceDestroyCPGroup(java.lang.String)"><code>CPSubsystemManagementService.forceDestroyCPGroup(String)</code></a>. For this
 reason, please make sure that you are completely done with a CP data
 structure before destroying its proxy.</strong>
 <p>
 By default, CP Subsystem works only in memory without persisting any state
 to disk. It means that a crashed CP member is not able to join to
 the cluster back by restoring its previous state. Therefore, crashed CP
 members create a danger for gradually losing majority of CP groups and
 eventually cause the total loss of availability of CP Subsystem. To prevent
 such situations, crashed CP members can be removed from CP Subsystem and
 replaced in CP groups with other available CP members. This flexibility
 provides a good degree of fault-tolerance at run-time. Please see
 <a href="../config/cp/CPSubsystemConfig.html" title="class in com.hazelcast.config.cp"><code>CPSubsystemConfig</code></a> and <a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a> for more
 details.
 <p>
 CP Subsystem offers disk persistence as well. When it is enabled via
 <a href="../config/cp/CPSubsystemConfig.html#setPersistenceEnabled(boolean)"><code>CPSubsystemConfig.setPersistenceEnabled(boolean)</code></a>, CP members persist
 their local state to stable storage and can restore their state after
 crashes. This capability significantly improves the overall reliability of
 CP Subsystem by enabling recovery of crashed CP members. When you restart
 crashed CP members, they restore their local state and resume working as if
 they have never crashed. If you cannot restart a CP member on the same
 machine, you can move its data to another machine and restart it with a new
 address. CP Subsystem Persistence enables you to handle single or multiple CP
 member crashes, or even whole cluster crashes and guarantee that committed
 operations are not lost after recovery. In other words, CP member crashes
 and restarts do not create any consistency problem. As long as majority of
 CP members are available after recovery, CP Subsystem remains operational.
 <p>
 When CP Subsystem Persistence is enabled, all Hazelcast cluster members
 create a sub-directory under the base persistence directory which is
 specified via <a href="../config/cp/CPSubsystemConfig.html#getBaseDir()"><code>CPSubsystemConfig.getBaseDir()</code></a>. This means that AP
 Hazelcast members, which are the ones not marked as CP members during
 the CP discovery process, create their persistence directories as well.
 Those members persist only the information that they are not CP members.
 This is done because when a Hazelcast member starts with CP Subsystem
 Persistence enabled, it checks if there is a CP persistence directory
 belonging to itself. If it founds one, it skips the CP discovery process and
 initializes its CP member identity from the persisted data. If it was an AP
 member before shutdown or crash, it restores this information and starts as
 an AP member. Otherwise, it could think that the CP discovery process has
 not been executed and trigger it, which would break CP Subsystem.
 <p>
 <strong>In light of this information, If you have both CP and AP members
 in your cluster when CP Subsystem Persistence is enabled, and if you want to
 perform a cluster-wide restart, you need to ensure that AP members are also
 restarted with their CP persistence directories.</strong>
 <p>
 There is a significant behavioral difference during CP member shutdown when
 CP Subsystem Persistence is enabled and disabled. When disabled (the default
 mode in which CP Subsystem works only in memory), a shutting down CP member
 is replaced with other available CP members in all of its CP groups in order
 not to decrease or more importantly not to lose majorities of CP groups.
 It is because CP members keep their local state only in memory when CP
 Subsystem Persistence is disabled, hence a shut-down CP member cannot join
 back with its CP identity and state, hence it is better to remove it from CP
 Subsystem to not to harm availability of CP groups. If there is no other
 available CP member to replace a shutting down CP member in a CP group, that
 CP group's size is reduced by 1 and its majority value is recalculated.
 On the other hand, when CP Subsystem Persistence is enabled, a shut-down CP
 member can come back by restoring its CP state. Therefore, it is not
 automatically removed from CP Subsystem when CP Subsystem Persistence is
 enabled. It is up to the user to remove shut-down CP members
 via <a href="CPSubsystemManagementService.html#removeCPMember(java.util.UUID)"><code>CPSubsystemManagementService.removeCPMember(UUID)</code></a> )} if they will
 not come back.
 <p>
 In summary, CP member shutdown behaviour is as follows:
 <ul>
 <li>When CP Subsystem Persistence is disabled (the default mode),
 shut-down CP members are removed from CP Subsystem and CP group majority
 values are recalculated.</li>
 <li>When CP Subsystem Persistence is enabled, shut-down CP members are
 still kept as part of CP Subsystem so they will be part of CP group majority
 calculations.</li>
 </ul>
 <p>
 <strong>Moreover, there is a subtle point about concurrent shutdown of CP
 members when CP Subsystem Persistence is disabled. If there are N CP members
 in CP Subsystem, <a href="../core/HazelcastInstance.html#shutdown()"><code>HazelcastInstance.shutdown()</code></a> can be called on N-2
 CP members concurrently. Once these N-2 CP members complete their shutdown,
 the remaining 2 CP members must be shut down serially. Even though
 the shutdown API can be called concurrently on multiple CP members, since
 the METADATA CP group handles shutdown requests serially, it would be simpler
 to shut down CP members one by one, by calling
 <a href="../core/HazelcastInstance.html#shutdown()"><code>HazelcastInstance.shutdown()</code></a> on the next CP member once the current
 CP member completes its shutdown. This rule does not apply when CP Subsystem
 Persistence is enabled so you can shut down your CP members concurrently
 if you enabled CP Subsystem Persistence. Please see <a href="CPSubsystem.html" title="interface in com.hazelcast.cp"><code>CPSubsystem</code></a>
 to learn more about the shut-down behaviour of CP members.</strong> It is
 enough for users to recall this rule while shutting down CP members when
 CP Subsystem Persistence is disabled. Interested users can read the rest of
 this paragraph to learn the reasoning behind this rule. Each shutdown
 request internally requires a Raft commit to the METADATA CP group when CP
 Subsystem Persistence is disabled. A CP member proceeds to shutdown after it
 receives a response of this commit. To be able to perform a Raft commit,
 the METADATA CP group must have its majority up and running. When only 2 CP
 members are left after graceful shutdowns, the majority of the METADATA CP
 group becomes 2. If the last 2 CP members shut down concurrently, one of
 them is likely to perform its Raft commit faster than the other one and
 leave the cluster before the other CP member completes its Raft commit.
 In this case, the last CP member waits for a response of its commit attempt
 on the METADATA CP group, and times out eventually. This situation causes
 an unnecessary delay on shutdown process of the last CP member. On the other
 hand, when the last 2 CP members shut down serially, the N-1th member
 receives the response of its commit after its shutdown request is committed
 also on the last CP member. Then, the last CP member checks its local data
 to notice that it is the last CP member alive, and proceeds its shutdown
 without attempting a Raft commit on the METADATA CP group.
 <p>
 CP Subsystem's fault tolerance capabilities are summarized below.
 For the sake of simplicity, let's assume that both the CP member count and
 CP group size configurations are configured as the same and we use only
 the DEFAULT CP group. <strong>In the list below, "a permanent crash"
 means that a CP member either crashes while CP Subsystem Persistence is
 disabled, hence it cannot be recovered with its CP identity and data, or
 it crashes while CP Subsystem Persistence is enabled but its CP data cannot
 be recovered, for instance, due to a total server crash or a disk failure.
 </strong>
 <ul>
 <li>If a CP member leaves the Hazelcast cluster, it is not automatically
 removed from CP Subsystem because CP Subsystem cannot certainly determine
 if that member has actually crashed or just disconnected from the cluster.
 Therefore, absent CP members are still considered in majority calculations
 and cause a danger for the availability of CP Subsystem. If the user knows
 for sure that an absent CP member is crashed, she can remove that CP member
 from CP Subsystem via
 <a href="CPSubsystemManagementService.html#removeCPMember(java.util.UUID)"><code>CPSubsystemManagementService.removeCPMember(UUID)</code></a>. This API call
 removes the given CP member from all CP groups and recalculates their
 majority values. If there is another available CP member in CP Subsystem,
 the removed CP member is replaced with that one, or the user can promote
 an AP member of the Hazelcast cluster to the CP role via
 <a href="CPSubsystemManagementService.html#promoteToCPMember()"><code>CPSubsystemManagementService.promoteToCPMember()</code></a>.</li>
 <li>There might be a small window of unavailability after a CP member crash
 even if the majority of CP members are still online. For instance, if
 a crashed CP member is the Raft leader for some CP groups, those CP groups
 run a new leader election round to elect a new leader among remaining CP
 group members. CP Subsystem API calls that internally hit those CP groups
 are retried until they have new Raft leaders. If a failed CP member has
 the Raft follower role, it causes a very minimal disruption since Raft
 leaders are still able to replicate and commit operations with the majority
 of their CP group members.</li>
 <li>If a crashed CP member is restarted after it is removed from CP
 Subsystem, its behaviour depends on if CP Subsystem Persistence is enabled
 or disabled. If CP Subsystem Persistence is enabled, a restarted CP member
 is not able to restore its CP data from disk because after it joins back to
 the cluster it notices that it is no longer a CP member. Because of that, it
 fails its startup process and prints an error message. The only thing to do
 in this case is manually delete its CP persistence directory since its data
 is no longer useful. On the other hand, if CP Subsystem Persistence is
 disabled, a failed CP member cannot remember anything related to its
 previous CP identity, hence it restarts as a new AP member.</li>
 <li>A CP member can be encounter a network issue and disconnect from
 the cluster. If it is removed from CP Subsystem by the user even though this
 CP member is actually alive but only disconnected, this CP member should be
 terminated to prevent any accidental communication with the other CP members
 in CP Subsystem.</li>
 <li>If a network partition occurs, behaviour of CP Subsystem depends on how
 CP members are divided in different sides of the network partition and
 to which sides Hazelcast clients are connected. Each CP group remains
 available on the side that contains the majority of its CP members. If
 a Raft leader falls into the minority side, its CP group elects a new Raft
 leader on the other side and callers that are talking to the majority side
 continue to make successful API calls on CP Subsystem. However, callers that
 are talking to the minority side fail with operation timeouts. When
 the network problem is resolved, CP members reconnect to each other and CP
 groups continue their operation normally.</li>
 <li>CP Subsystem can tolerate failure of the minority of CP members (less
 than N / 2 + 1) for availability. If N / 2 + 1 or more CP members crash, CP
 Subsystem loses its availability. If CP Subsystem Persistence is enabled and
 the majority of CP members become online by successfully restarting some of
 failed CP members, CP Subsystem regains its availability back. <strong>
 Otherwise, it means that CP Subsystem has lost its majority irrevocably.
 </strong> In this case, the only solution is to wipe-out the whole CP
 Subsystem state by performing a force-reset via
 <a href="CPSubsystemManagementService.html#reset()"><code>CPSubsystemManagementService.reset()</code></a>.</li>
 </ul>
 <p>
 <strong>When <a href="../config/cp/CPSubsystemConfig.html#getCPMemberCount()"><code>CPSubsystemConfig.getCPMemberCount()</code></a> is greater than
 <a href="../config/cp/CPSubsystemConfig.html#getGroupSize()"><code>CPSubsystemConfig.getGroupSize()</code></a>, CP groups are formed by selecting
 a subset of CP members. In this case, each CP group can have a different set
 of CP members, therefore different fault-tolerance and availability
 conditions.</strong> In the following list, CP Subsystem's additional fault
 tolerance capabilities are discussed for this configuration case.
 <ul>
 <li>When the majority of a non-METADATA CP group permanently crash, that CP
 group cannot make progress anymore, even though other CP groups in CP
 Subsystem are running fine. Even a new CP member cannot join to this CP
 group, because membership changes also go through the Raft consensus
 algorithm. For this reason, the only option is to force-destroy this CP
 group via
 <a href="CPSubsystemManagementService.html#forceDestroyCPGroup(java.lang.String)"><code>CPSubsystemManagementService.forceDestroyCPGroup(String)</code></a>. When this
 API is called, the CP group is terminated non-gracefully without the Raft
 mechanics. After this API call, all existing CP data structure proxies that
 talk to this CP group fail with <a href="exception/CPGroupDestroyedException.html" title="class in com.hazelcast.cp.exception"><code>CPGroupDestroyedException</code></a>. However,
 if a new proxy is created afterwards, then this CP group is re-created from
 scratch with a new set of CP members. Losing majority of a non-METADATA CP
 group can be likened to partition-loss scenario of AP Hazelcast. Please note
 that non-METADATA CP groups that have lost their majority must be
 force-destroyed immediately, because they can block the METADATA CP group
 to perform membership changes on CP Subsystem.</li>
 <li>If the majority of the METADATA CP group permanently crash,
 unfortunately it is equivalent to the permanent crash of the majority
 CP members of the whole CP Subsystem, even though other CP groups are
 running fine. In fact, existing CP groups continue serving to incoming
 requests, but since the METADATA CP group is not available anymore, no
 management tasks can be performed on CP Subsystem. For instance, a new CP
 group cannot be created. The only solution is to perform a force-reset
 which wipes-out the whole CP Subsystem state via
 <a href="CPSubsystemManagementService.html#reset()"><code>CPSubsystemManagementService.reset()</code></a>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../config/cp/CPSubsystemConfig.html" title="class in com.hazelcast.config.cp"><code>CPSubsystemConfig</code></a>, 
<a href="CPMember.html" title="interface in com.hazelcast.cp"><code>CPMember</code></a>, 
<a href="CPGroup.html" title="interface in com.hazelcast.cp"><code>CPGroup</code></a>, 
<a href="session/CPSession.html" title="interface in com.hazelcast.cp.session"><code>CPSession</code></a>, 
<a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addGroupAvailabilityListener(com.hazelcast.cp.event.CPGroupAvailabilityListener)">addGroupAvailabilityListener</a></span>&#8203;(<a href="event/CPGroupAvailabilityListener.html" title="interface in com.hazelcast.cp.event">CPGroupAvailabilityListener</a>&nbsp;listener)</code></th>
<td class="col-last">
<div class="block">Registers a new CPGroupAvailabilityListener to listen CP group availability changes.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addMembershipListener(com.hazelcast.cp.event.CPMembershipListener)">addMembershipListener</a></span>&#8203;(<a href="event/CPMembershipListener.html" title="interface in com.hazelcast.cp.event">CPMembershipListener</a>&nbsp;listener)</code></th>
<td class="col-last">
<div class="block">Registers a new CPMembershipListener to listen CP membership changes.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code><a href="IAtomicLong.html" title="interface in com.hazelcast.cp">IAtomicLong</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getAtomicLong(java.lang.String)">getAtomicLong</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Returns a proxy for an <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance created on CP
 Subsystem.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>&lt;E&gt;&nbsp;<a href="IAtomicReference.html" title="interface in com.hazelcast.cp">IAtomicReference</a>&lt;E&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getAtomicReference(java.lang.String)">getAtomicReference</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Returns a proxy for an <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> instance created on
 CP Subsystem.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code><a href="ICountDownLatch.html" title="interface in com.hazelcast.cp">ICountDownLatch</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getCountDownLatch(java.lang.String)">getCountDownLatch</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Returns a proxy for an <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> instance created on
 CP Subsystem.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code><a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session">CPSessionManagementService</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getCPSessionManagementService()">getCPSessionManagementService</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the <a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session"><code>CPSessionManagementService</code></a> of this Hazelcast
 instance.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code><a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp">CPSubsystemManagementService</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getCPSubsystemManagementService()">getCPSubsystemManagementService</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the <a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a> of this Hazelcast
 instance.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code><a href="CPMember.html" title="interface in com.hazelcast.cp">CPMember</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getLocalCPMember()">getLocalCPMember</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the local CP member if this Hazelcast member is part of
 CP Subsystem, returns null otherwise.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code><a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock">FencedLock</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getLock(java.lang.String)">getLock</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Returns a proxy for an <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance created on CP
 Subsystem.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code><a href="ISemaphore.html" title="interface in com.hazelcast.cp">ISemaphore</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSemaphore(java.lang.String)">getSemaphore</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></th>
<td class="col-last">
<div class="block">Returns a proxy for an <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> instance created on CP
 Subsystem.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#removeGroupAvailabilityListener(java.util.UUID)">removeGroupAvailabilityListener</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a>&nbsp;id)</code></th>
<td class="col-last">
<div class="block">Removes CPGroupAvailabilityListener registration.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#removeMembershipListener(java.util.UUID)">removeMembershipListener</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a>&nbsp;id)</code></th>
<td class="col-last">
<div class="block">Removes membership listener registration.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="getAtomicLong(java.lang.String)">
<h3>getAtomicLong</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="IAtomicLong.html" title="interface in com.hazelcast.cp">IAtomicLong</a></span>&nbsp;<span class="member-name">getAtomicLong</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns a proxy for an <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance created on CP
 Subsystem. Hazelcast's <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> is a distributed version of
 <tt>java.util.concurrent.atomic.AtomicLong</tt>. If no group name is
 given within the "name" parameter, then the <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance
 will be created on the DEFAULT CP group. If a group name is given, like
 <code>.getAtomicLong("myLong@group1")</code>, the given group will be
 initialized first, if not initialized already, and then the
 <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance will be created on this group. Returned
 <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> instance offers linearizability and behaves as a CP
 register. When a network partition occurs, proxies that exist on the
 minority side of its CP group lose availability.
 <p>
 <strong>Each call of this method performs a commit to the METADATA CP
 group. Hence, callers should cache the returned proxy.</strong></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - name of the <a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> proxy</dd>
<dt>Returns:</dt>
<dd><a href="IAtomicLong.html" title="interface in com.hazelcast.cp"><code>IAtomicLong</code></a> proxy for the given name</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getAtomicReference(java.lang.String)">
<h3>getAtomicReference</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="type-parameters">&lt;E&gt;</span>&nbsp;<span class="return-type"><a href="IAtomicReference.html" title="interface in com.hazelcast.cp">IAtomicReference</a>&lt;E&gt;</span>&nbsp;<span class="member-name">getAtomicReference</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns a proxy for an <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> instance created on
 CP Subsystem. Hazelcast's <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> is a distributed
 version of <tt>java.util.concurrent.atomic.AtomicReference</tt>. If no group
 name is given within the "name" parameter, then
 the <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> instance will be created on the DEFAULT CP
 group. If a group name is given, like
 <code>.getAtomicReference("myRef@group1")</code>, the given group will be
 initialized first, if not initialized already, and then the
 <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> instance will be created on this group.
 Returned <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> instance offers linearizability and
 behaves as a CP register. When a network partition occurs, proxies that
 exist on the minority side of its CP group lose availability.
 <p>
 <strong>Each call of this method performs a commit to the METADATA CP
 group. Hence, callers should cache the returned proxy.</strong></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>E</code> - the type of object referred to by the reference</dd>
<dt>Parameters:</dt>
<dd><code>name</code> - name of the <a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> proxy</dd>
<dt>Returns:</dt>
<dd><a href="IAtomicReference.html" title="interface in com.hazelcast.cp"><code>IAtomicReference</code></a> proxy for the given name</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCountDownLatch(java.lang.String)">
<h3>getCountDownLatch</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="ICountDownLatch.html" title="interface in com.hazelcast.cp">ICountDownLatch</a></span>&nbsp;<span class="member-name">getCountDownLatch</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns a proxy for an <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> instance created on
 CP Subsystem. Hazelcast's <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> is a distributed
 version of <tt>java.util.concurrent.CountDownLatch</tt>. If no group
 name is given within the "name" parameter, then
 the <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> instance will be created on the DEFAULT CP
 group. If a group name is given, like
 <code>.getCountDownLatch("myLatch@group1")</code>, the given group will be
 initialized first, if not initialized already, and then the
 <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> instance will be created on this group. Returned
 <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> instance offers linearizability. When a network
 partition occurs, proxies that exist on the minority side of its CP
 group lose availability.
 <p>
 <strong>Each call of this method performs a commit to the METADATA CP
 group. Hence, callers should cache the returned proxy.</strong></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - name of the <a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> proxy</dd>
<dt>Returns:</dt>
<dd><a href="ICountDownLatch.html" title="interface in com.hazelcast.cp"><code>ICountDownLatch</code></a> proxy for the given name</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getLock(java.lang.String)">
<h3>getLock</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock">FencedLock</a></span>&nbsp;<span class="member-name">getLock</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns a proxy for an <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance created on CP
 Subsystem. Hazelcast's <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> is a distributed version of
 <tt>java.util.concurrent.locks.Lock</tt>. If no group name is given
 within the "name" parameter, then the <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance will
 be created on the DEFAULT CP group. If a group name is given, like
 <code>.getLock("myLock@group1")</code>, the given group will be initialized
 first, if not initialized already, and then the <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a>
 instance will be created on this group. Returned <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a>
 instance offers linearizability. When a network partition occurs,
 proxies that exist on the minority side of its CP group lose
 availability.
 <p>
 <strong>Each call of this method performs a commit to the METADATA CP
 group. Hence, callers should cache the returned proxy.</strong></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - name of the <a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> proxy</dd>
<dt>Returns:</dt>
<dd><a href="lock/FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> proxy for the given name</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
<dt>See Also:</dt>
<dd><a href="../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSemaphore(java.lang.String)">
<h3>getSemaphore</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
</span><span class="return-type"><a href="ISemaphore.html" title="interface in com.hazelcast.cp">ISemaphore</a></span>&nbsp;<span class="member-name">getSemaphore</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html" title="class or interface in javax.annotation" class="external-link">@Nonnull</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns a proxy for an <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> instance created on CP
 Subsystem. Hazelcast's <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> is a distributed version of
 <tt>java.util.concurrent.Semaphore</tt>. If no group name is given
 within the "name" parameter, then the <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> instance will
 be created on the DEFAULT CP group. If a group name is given, like
 <code>.getSemaphore("mySemaphore@group1")</code>, the given group will be
 initialized first, if not initialized already, and then the
 <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> instance will be created on this group. Returned
 <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> instance offers linearizability. When a network
 partition occurs, proxies that exist on the minority side of its CP
 group lose availability.
 <p>
 <strong>Each call of this method performs a commit to the METADATA CP
 group. Hence, callers should cache the returned proxy.</strong></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - name of the <a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> proxy</dd>
<dt>Returns:</dt>
<dd><a href="ISemaphore.html" title="interface in com.hazelcast.cp"><code>ISemaphore</code></a> proxy for the given name</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
<dt>See Also:</dt>
<dd><a href="../config/cp/SemaphoreConfig.html" title="class in com.hazelcast.config.cp"><code>SemaphoreConfig</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getLocalCPMember()">
<h3>getLocalCPMember</h3>
<div class="member-signature"><span class="return-type"><a href="CPMember.html" title="interface in com.hazelcast.cp">CPMember</a></span>&nbsp;<span class="member-name">getLocalCPMember</span>()</div>
<div class="block">Returns the local CP member if this Hazelcast member is part of
 CP Subsystem, returns null otherwise.
 <p>
 This method is a shortcut for <a href="CPSubsystemManagementService.html#getLocalCPMember()"><code>CPSubsystemManagementService.getLocalCPMember()</code></a>
 method. Calling this method is equivalent to calling
 <code>getCPSubsystemManagementService().getLocalCPMember()</code>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>local CP member if available, null otherwise</dd>
<dt>Throws:</dt>
<dd><code><a href="../core/HazelcastException.html" title="class in com.hazelcast.core">HazelcastException</a></code> - if CP Subsystem is not enabled</dd>
<dt>See Also:</dt>
<dd><a href="CPSubsystemManagementService.html#getLocalCPMember()"><code>CPSubsystemManagementService.getLocalCPMember()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCPSubsystemManagementService()">
<h3>getCPSubsystemManagementService</h3>
<div class="member-signature"><span class="return-type"><a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp">CPSubsystemManagementService</a></span>&nbsp;<span class="member-name">getCPSubsystemManagementService</span>()</div>
<div class="block">Returns the <a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a> of this Hazelcast
 instance. <a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a> offers APIs for managing
 CP members and CP groups.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the <a href="CPSubsystemManagementService.html" title="interface in com.hazelcast.cp"><code>CPSubsystemManagementService</code></a> of this Hazelcast instance</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCPSessionManagementService()">
<h3>getCPSessionManagementService</h3>
<div class="member-signature"><span class="return-type"><a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session">CPSessionManagementService</a></span>&nbsp;<span class="member-name">getCPSessionManagementService</span>()</div>
<div class="block">Returns the <a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session"><code>CPSessionManagementService</code></a> of this Hazelcast
 instance. <a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session"><code>CPSessionManagementService</code></a> offers APIs for managing CP
 sessions.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the <a href="session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session"><code>CPSessionManagementService</code></a> of this Hazelcast instance</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addMembershipListener(com.hazelcast.cp.event.CPMembershipListener)">
<h3>addMembershipListener</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a></span>&nbsp;<span class="member-name">addMembershipListener</span>&#8203;(<span class="parameters"><a href="event/CPMembershipListener.html" title="interface in com.hazelcast.cp.event">CPMembershipListener</a>&nbsp;listener)</span></div>
<div class="block">Registers a new CPMembershipListener to listen CP membership changes.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>listener</code> - membership listener</dd>
<dt>Returns:</dt>
<dd>id of the listener registration</dd>
<dt>Since:</dt>
<dd>4.1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeMembershipListener(java.util.UUID)">
<h3>removeMembershipListener</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">removeMembershipListener</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a>&nbsp;id)</span></div>
<div class="block">Removes membership listener registration. Previously registered listener
 will not receive further events.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>id</code> - of the registration</dd>
<dt>Returns:</dt>
<dd>true if listener registration is removed, false otherwise</dd>
<dt>Since:</dt>
<dd>4.1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addGroupAvailabilityListener(com.hazelcast.cp.event.CPGroupAvailabilityListener)">
<h3>addGroupAvailabilityListener</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a></span>&nbsp;<span class="member-name">addGroupAvailabilityListener</span>&#8203;(<span class="parameters"><a href="event/CPGroupAvailabilityListener.html" title="interface in com.hazelcast.cp.event">CPGroupAvailabilityListener</a>&nbsp;listener)</span></div>
<div class="block">Registers a new CPGroupAvailabilityListener to listen CP group availability changes.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>listener</code> - group availability listener</dd>
<dt>Returns:</dt>
<dd>id of the listener registration</dd>
<dt>Since:</dt>
<dd>4.1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeGroupAvailabilityListener(java.util.UUID)">
<h3>removeGroupAvailabilityListener</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">removeGroupAvailabilityListener</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" title="class or interface in java.util" class="external-link">UUID</a>&nbsp;id)</span></div>
<div class="block">Removes CPGroupAvailabilityListener registration.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>id</code> - of the registration</dd>
<dt>Returns:</dt>
<dd>true if listener registration is removed, false otherwise</dd>
<dt>Since:</dt>
<dd>4.1</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/CPSubsystem.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
