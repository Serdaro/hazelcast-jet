<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (14) on Tue Dec 21 08:36:16 CET 2021 -->
<title>FencedLock (hazelcast-jet-distribution 4.5.3 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-12-21">
<meta name="description" content="declaration: package: com.hazelcast.cp.lock, interface: FencedLock">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/FencedLock.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.hazelcast.cp.lock</a></div>
<h1 title="Interface FencedLock" class="title">Interface FencedLock</h1>
</div>
<div class="contentContainer">
<section class="description">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="../../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></code>, <code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">FencedLock</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a>, <a href="../../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></pre>
<div class="block">A linearizable &amp; distributed &amp; reentrant implementation of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink"><code>Lock</code></a>.
 <p>
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> is accessed via <a href="../CPSubsystem.html#getLock(java.lang.String)"><code>CPSubsystem.getLock(String)</code></a>.
 <p>
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> is CP with respect to the CAP principle. It works on top
 of the Raft consensus algorithm. It offers linearizability during crash-stop
 failures and network partitions. If a network partition occurs, it remains
 available on at most one side of the partition.
 <p>
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> works on top of CP sessions. Please see <a href="../session/CPSession.html" title="interface in com.hazelcast.cp.session"><code>CPSession</code></a>
 for more information about CP sessions.
 <p>
 By default, <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> is reentrant. Once a caller acquires
 the lock, it can acquire the lock reentrantly as many times as it wants
 in a linearizable manner. You can configure the reentrancy behaviour via
 <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a>. For instance, reentrancy can be disabled and
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> can work as a non-reentrant mutex. One can also set
 a custom reentrancy limit. When the reentrancy limit is reached,
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> does not block a lock call. Instead, it fails with
 <a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockAcquireLimitReachedException</code></a> or a specified return value.
 Please check the locking methods to see details about the behaviour.
 <p>
 Distributed locks are unfortunately NOT EQUIVALENT to single-node mutexes
 because of the complexities in distributed systems, such as uncertain
 communication patterns, and independent and partial failures.
 In an asynchronous network, no lock service can guarantee mutual exclusion,
 because there is no way to distinguish between a slow and a crashed process.
 Consider the following scenario, where a Hazelcast client acquires
 a <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a>, then hits a long GC pause. Since it will not be able
 to commit session heartbeats while paused, its CP session will be eventually
 closed. After this moment, another Hazelcast client can acquire this lock.
 If the first client wakes up again, it may not immediately notice that it
 has lost ownership of the lock. In this case, multiple clients think they
 hold the lock. If they attempt to perform an operation on a shared resource,
 they can break the system. To prevent such situations, you can choose to use
 an infinite session timeout, but this time probably you are going to deal
 with liveliness issues. For the scenario above, even if the first client
 actually crashes, requests sent by 2 clients can be re-ordered in the network
 and hit the external resource in reverse order.
 <p>
 There is a simple solution for this problem. Lock holders are ordered by a
 monotonic fencing token, which increments each time the lock is assigned to
 a new owner. This fencing token can be passed to external services or
 resources to ensure sequential execution of side effects performed by lock
 holders.
 <p>
 The following figure illustrates the idea. Client-1 acquires the lock first
 and receives 1 as its fencing token. Then, it passes this token to the
 external service, which is our shared resource in this scenario.
 Just after that, Client-1 hits a long GC pause and eventually loses
 ownership of the lock because it misses to commit CP session heartbeats.
 Then, Client-2 chimes in and acquires the lock. Similar to Client-1,
 Client-2 passes its fencing token to the external service. After that,
 once Client-1 comes back alive, its write request will be rejected
 by the external service, and only Client-2 will be able to safely talk it.
 <pre>
                                                       CLIENT-1's session is expired.
                                                                    |
 |------------------|               LOCK is acquired by CLIENT-1.   |     LOCK is acquired by CLIENT-2.
 |       LOCK       | . . . . . . . - - - - - - - - - - - - - - - - | . . + + + + + + + + + + + + + + + + + + + + + + + + + + +
 |------------------|             /\ \ fence = 1                    |   /| \ fence = 2
                                 /    \                                /    \
 |------------------|           /      \       |                      /      \         | CLIENT-1 wakes up.
 |     CLIENT-1     | . . . . ./. . . . \/. . .|_ _ _ _ _ _ _ _ _ _  /_ _ _ _ \ _ _ _ _|. . . . . . . . . . . . . . . . . . . .
 |------------------|    lock()            \    CLIENT-1 is paused. /          \    write(A) \
                               set_fence(1) \                      /            \             \
 |------------------|                        \                    /              \             \
 |     CLIENT-2     | . . . . . . . . . . . . \ . . . . . . . . ./. . . . . . . . \/. . . . . . \ . . . . . . . . . . . . . . .
 |------------------|                          \           lock()                    \           \      write(B) \
                                                \                        set_fence(2) \           \               \
 |------------------|                            \   |                                 \   |       \               \
 | EXTERNAL SERVICE | . . . . . . . . . . . . . . \/ |- - - - - - - - - - - - - - - - - \/ |+ + + + \/  + + + + + + \/  + + + +
 |------------------|                                |                                     | write(A) fails.    write(B) ok.
                                                     | SERVICE belongs to CLIENT-1.        | SERVICE belongs to CLIENT-2.
 </pre>
 You can read more about the fencing token idea in Martin Kleppmann's
 "How to do distributed locking" blog post and Google's Chubby paper.
 <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> integrates this idea with the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink"><code>Lock</code></a>
 abstraction.
 <p>
 All of the API methods in the new <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> abstraction offer
 exactly-once execution semantics. For instance, even if a <a href="#lock()"><code>lock()</code></a>
 call is internally retried because of a crashed CP member, the lock is
 acquired only once. The same rule also applies to the other methods
 in the API.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a>, 
<a href="../session/CPSessionManagementService.html" title="interface in com.hazelcast.cp.session"><code>CPSessionManagementService</code></a>, 
<a href="../session/CPSession.html" title="interface in com.hazelcast.cp.session"><code>CPSession</code></a>, 
<a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a>, 
<a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockAcquireLimitReachedException</code></a></dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#INVALID_FENCE">INVALID_FENCE</a></span></code></th>
<td class="colLast">
<div class="block">Representation of a failed lock attempt where
 the caller thread has not acquired the lock</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFence()">getFence</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the fencing token if the lock is held by the current thread.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../CPGroupId.html" title="interface in com.hazelcast.cp">CPGroupId</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGroupId()">getGroupId</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns id of the CP group that runs this <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLockCount()">getLockCount</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the reentrant lock count if the lock is held by any thread
 in the cluster.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLocked()">isLocked</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns whether this lock is locked or not.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLockedByCurrentThread()">isLockedByCurrentThread</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns whether the lock is held by the current thread or not.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lock()">lock</a></span>()</code></th>
<td class="colLast">
<div class="block">Acquires the lock.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lockAndGetFence()">lockAndGetFence</a></span>()</code></th>
<td class="colLast">
<div class="block">Acquires the lock and returns the fencing token assigned to the current
 thread for this lock acquire.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lockInterruptibly()">lockInterruptibly</a></span>()</code></th>
<td class="colLast">
<div class="block">Acquires the lock unless the current thread is
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html?is-external=true#interrupt()" title="class or interface in java.lang" class="externalLink">interrupted</a>.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Condition</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newCondition()">newCondition</a></span>()</code></th>
<td class="colLast">
<div class="block">NOT IMPLEMENTED.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLock()">tryLock</a></span>()</code></th>
<td class="colLast">
<div class="block">Acquires the lock if it is available or already held by the current
 thread at the time of invocation &amp; the acquire limit is not exceeded,
 and immediately returns with the value <code>true</code>.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLock(long,java.util.concurrent.TimeUnit)">tryLock</a></span>&#8203;(long&nbsp;time,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html?is-external=true" title="class or interface in java.util.concurrent" class="externalLink">TimeUnit</a>&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Acquires the lock if it is free within the given waiting time,
 or already held by the current thread.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLockAndGetFence()">tryLockAndGetFence</a></span>()</code></th>
<td class="colLast">
<div class="block">Acquires the lock only if it is free or already held by the current
 thread at the time of invocation &amp; the acquire limit is not exceeded,
 and returns the fencing token assigned to the current thread for this
 lock acquire.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLockAndGetFence(long,java.util.concurrent.TimeUnit)">tryLockAndGetFence</a></span>&#8203;(long&nbsp;time,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html?is-external=true" title="class or interface in java.util.concurrent" class="externalLink">TimeUnit</a>&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Acquires the lock if it is free within the given waiting time,
 or already held by the current thread at the time of invocation &amp;
 the acquire limit is not exceeded, and returns the fencing token
 assigned to the current thread for this lock acquire.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlock()">unlock</a></span>()</code></th>
<td class="colLast">
<div class="block">Releases the lock if the lock is currently held by the current thread.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;com.hazelcast.core.<a href="../../core/DistributedObject.html" title="interface in com.hazelcast.core">DistributedObject</a></h3>
<a id="methods.inherited.from.class.com.hazelcast.core.DistributedObject">
<!--   -->
</a><code><a href="../../core/DistributedObject.html#destroy()">destroy</a>, <a href="../../core/DistributedObject.html#getDestroyContextForTenant()">getDestroyContextForTenant</a>, <a href="../../core/DistributedObject.html#getName()">getName</a>, <a href="../../core/DistributedObject.html#getPartitionKey()">getPartitionKey</a>, <a href="../../core/DistributedObject.html#getServiceName()">getServiceName</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="INVALID_FENCE">INVALID_FENCE</a></h3>
<div class="memberSignature"><span class="modifiers">static final</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName">INVALID_FENCE</span></div>
<div class="block">Representation of a failed lock attempt where
 the caller thread has not acquired the lock</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#com.hazelcast.cp.lock.FencedLock.INVALID_FENCE">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="lock()">lock</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">lock</span>()</div>
<div class="block">Acquires the lock.
 <p>
 When the caller already holds the lock and the current lock() call is
 reentrant, the call can fail with
 <a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockAcquireLimitReachedException</code></a> if the lock acquire limit is
 already reached. Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more
 information.
 <p>
 If the lock is not available then the current thread becomes disabled
 for thread scheduling purposes and lies dormant until the lock has been
 acquired.
 <p>
 Consider the following scenario:
 <pre>
     FencedLock lock = ...;
     lock.lock();
     // JVM of the caller thread hits a long pause
     // and its CP session is closed on the CP group.
     lock.lock();
 </pre>
 In this scenario, a thread acquires the lock, then its JVM instance
 encounters a long pause, which is longer than
 <a href="../../config/cp/CPSubsystemConfig.html#getSessionTimeToLiveSeconds()"><code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code></a>. In this case,
 its CP session will be closed on the corresponding CP group because
 it could not commit session heartbeats in the meantime. After the JVM
 instance wakes up again, the same thread attempts to acquire the lock
 reentrantly. In this case, the second lock() call fails by throwing
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> which extends
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>. If the caller wants to deal with
 its session loss by taking some custom actions, it can handle the thrown
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> instance. Otherwise, it can treat it
 as a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#lock()" title="class or interface in java.util.concurrent.locks" class="externalLink">lock</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
<dd><code><a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception">LockAcquireLimitReachedException</a></code> - if the lock call is reentrant
         and the configured lock acquire limit is already reached.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="lockInterruptibly()">lockInterruptibly</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">lockInterruptibly</span>()
                throws <span class="exceptions"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html?is-external=true" title="class or interface in java.lang" class="externalLink">InterruptedException</a></span></div>
<div class="block">Acquires the lock unless the current thread is
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html?is-external=true#interrupt()" title="class or interface in java.lang" class="externalLink">interrupted</a>.
 <p>
 When the caller already holds the lock and the current lock() call is
 reentrant, the call can fail with
 <a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockAcquireLimitReachedException</code></a> if the lock acquire limit is
 already reached. Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more
 information.
 <p>
 If the lock is not available then the current thread becomes disabled
 for thread scheduling purposes and lies dormant until the lock has been
 acquired. Interruption may not be possible after the lock request
 arrives to the CP group, if the proxy does not attempt to retry its
 lock request because of a failure in the system.
 <p>
 Please note that even if <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>InterruptedException</code></a> is thrown,
 the lock may be acquired on the CP group.
 <p>
 When <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>InterruptedException</code></a> is thrown, the current thread's
 interrupted status is cleared.
 <p>
 Consider the following scenario:
 <pre>
     FencedLock lock = ...;
     lock.lockInterruptibly();
     // JVM of the caller thread hits a long pause
     // and its CP session is closed on the CP group.
     lock.lockInterruptibly();
 </pre>
 In this scenario, a thread acquires the lock, then its JVM instance
 encounters a long pause, which is longer than
 <a href="../../config/cp/CPSubsystemConfig.html#getSessionTimeToLiveSeconds()"><code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code></a>. In this case,
 its CP session will be closed on the corresponding CP group because
 it could not commit session heartbeats in the meantime. After the JVM
 instance wakes up again, the same thread attempts to acquire the lock
 reentrantly. In this case, the second lock() call fails by throwing
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> which extends
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>. If the caller wants to deal with
 its session loss by taking some custom actions, it can handle the thrown
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> instance. Otherwise, it can treat it
 as a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#lockInterruptibly()" title="class or interface in java.util.concurrent.locks" class="externalLink">lockInterruptibly</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html?is-external=true" title="class or interface in java.lang" class="externalLink">InterruptedException</a></code> - if the current thread is interrupted while
         acquiring the lock.</dd>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
<dd><code><a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception">LockAcquireLimitReachedException</a></code> - if the lock call is reentrant
         and the configured lock acquire limit is already reached.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="lockAndGetFence()">lockAndGetFence</a></h3>
<div class="memberSignature"><span class="returnType">long</span>&nbsp;<span class="memberName">lockAndGetFence</span>()</div>
<div class="block">Acquires the lock and returns the fencing token assigned to the current
 thread for this lock acquire. If the lock is acquired reentrantly,
 the same fencing token is returned, or the lock() call can fail with
 <a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockAcquireLimitReachedException</code></a> if the lock acquire limit is
 already reached. Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more
 information.
 <p>
 If the lock is not available then the current thread becomes disabled
 for thread scheduling purposes and lies dormant until the lock has been
 acquired.
 <p>
 This is a convenience method for the following pattern:
 <pre>
     FencedLock lock = ...;
     lock.lock();
     return lock.getFence();
 </pre>
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
     FencedLock lock = ...; // the lock is free
     lock.lockAndGetFence();
     // JVM of the caller thread hits a long pause
     // and its CP session is closed on the CP group.
     lock.lockAndGetFence();
 </pre>
 In this scenario, a thread acquires the lock, then its JVM instance
 encounters a long pause, which is longer than
 <a href="../../config/cp/CPSubsystemConfig.html#getSessionTimeToLiveSeconds()"><code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code></a>. In this case,
 its CP session will be closed on the corresponding CP group because
 it could not commit session heartbeats in the meantime. After the JVM
 instance wakes up again, the same thread attempts to acquire the lock
 reentrantly. In this case, the second lock() call fails by throwing
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> which extends
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>. If the caller wants to deal with
 its session loss by taking some custom actions, it can handle the thrown
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> instance. Otherwise, it can treat it
 as a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>.
 <p>
 Fencing tokens are monotonic numbers that are incremented each time
 the lock switches from the free state to the acquired state. They are
 simply used for ordering lock holders. A lock holder can pass
 its fencing to the shared resource to fence off previous lock holders.
 When this resource receives an operation, it can validate the fencing
 token in the operation.
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
     FencedLock lock = ...; // the lock is free
     long fence1 = lock.lockAndGetFence(); // (1)
     long fence2 = lock.lockAndGetFence(); // (2)
     assert fence1 == fence2;
     lock.unlock();
     lock.unlock();
     long fence3 = lock.lockAndGetFence(); // (3)
     assert fence3 &gt; fence1;
 </pre>
 In this scenario, the lock is acquired by a thread in the cluster. Then,
 the same thread reentrantly acquires the lock again. The fencing token
 returned from the second acquire is equal to the one returned from the
 first acquire, because of reentrancy. After the second acquire, the lock
 is released 2 times, hence becomes free. There is a third lock acquire
 here, which returns a new fencing token. Because this last lock acquire
 is not reentrant, its fencing token is guaranteed to be larger than the
 previous tokens, independent of the thread that has acquired the lock.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
<dd><code><a href="exception/LockAcquireLimitReachedException.html" title="class in com.hazelcast.cp.lock.exception">LockAcquireLimitReachedException</a></code> - if the lock call is reentrant
         and the configured lock acquire limit is already reached.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="tryLock()">tryLock</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">tryLock</span>()</div>
<div class="block">Acquires the lock if it is available or already held by the current
 thread at the time of invocation &amp; the acquire limit is not exceeded,
 and immediately returns with the value <code>true</code>. If the lock is not
 available, then this method immediately returns with the value
 <code>false</code>. When the call is reentrant, it can return <code>false</code>
 if the lock acquire limit is exceeded. Please see
 <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more information.
 <p>
 A typical usage idiom for this method would be:
 <pre>
     FencedLock lock = ...;
     if (lock.tryLock()) {
         try {
             // manipulate protected state
         } finally {
             lock.unlock();
         }
     } else {
         // perform alternative actions
     }
 </pre>
 This usage ensures that the lock is unlocked if it was acquired,
 and doesn't try to unlock if the lock was not acquired.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#tryLock()" title="class or interface in java.util.concurrent.locks" class="externalLink">tryLock</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the lock was acquired and
         <code>false</code> otherwise</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="tryLockAndGetFence()">tryLockAndGetFence</a></h3>
<div class="memberSignature"><span class="returnType">long</span>&nbsp;<span class="memberName">tryLockAndGetFence</span>()</div>
<div class="block">Acquires the lock only if it is free or already held by the current
 thread at the time of invocation &amp; the acquire limit is not exceeded,
 and returns the fencing token assigned to the current thread for this
 lock acquire. If the lock is acquired reentrantly, the same fencing
 token is returned. If the lock is already held by another caller or
 the lock acquire limit is exceeded, then this method immediately returns
 <a href="#INVALID_FENCE"><code>INVALID_FENCE</code></a> that represents a failed lock attempt.
 Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more information.
 <p>
 This is a convenience method for the following pattern:
 <pre>
     FencedLock lock = ...;
     if (lock.tryLock()) {
         return lock.getFence();
     } else {
         return FencedLock.INVALID_FENCE;
     }
 </pre>
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
     FencedLock lock = ...; // the lock is free
     lock.tryLockAndGetFence();
     // JVM of the caller thread hits a long pause
     // and its CP session is closed on the CP group.
     lock.tryLockAndGetFence();
 </pre>
 In this scenario, a thread acquires the lock, then its JVM instance
 encounters a long pause, which is longer than
 <a href="../../config/cp/CPSubsystemConfig.html#getSessionTimeToLiveSeconds()"><code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code></a>. In this case,
 its CP session will be closed on the corresponding CP group because
 it could not commit session heartbeats in the meantime. After the JVM
 instance wakes up again, the same thread attempts to acquire the lock
 reentrantly. In this case, the second lock() call fails by throwing
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> which extends
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>. If the caller wants to deal with
 its session loss by taking some custom actions, it can handle the thrown
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> instance. Otherwise, it can treat it
 as a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>.
 <p>
 Fencing tokens are monotonic numbers that are incremented each time
 the lock switches from the free state to the acquired state. They are
 simply used for ordering lock holders. A lock holder can pass
 its fencing to the shared resource to fence off previous lock holders.
 When this resource receives an operation, it can validate the fencing
 token in the operation.
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
     FencedLock lock = ...; // the lock is free
     long fence1 = lock.tryLockAndGetFence(); // (1)
     long fence2 = lock.tryLockAndGetFence(); // (2)
     assert fence1 == fence2;
     lock.unlock();
     lock.unlock();
     long fence3 = lock.tryLockAndGetFence(); // (3)
     assert fence3 &gt; fence1;
 </pre>
 In this scenario, the lock is acquired by a thread in the cluster. Then,
 the same thread reentrantly acquires the lock again. The fencing token
 returned from the second acquire is equal to the one returned from the
 first acquire, because of reentrancy. After the second acquire, the lock
 is released 2 times, hence becomes free. There is a third lock acquire
 here, which returns a new fencing token. Because this last lock acquire
 is not reentrant, its fencing token is guaranteed to be larger than the
 previous tokens, independent of the thread that has acquired the lock.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the fencing token if the lock was acquired and
         <a href="#INVALID_FENCE"><code>INVALID_FENCE</code></a> otherwise</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="tryLock(long,java.util.concurrent.TimeUnit)">tryLock</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">tryLock</span>&#8203;(<span class="arguments">long&nbsp;time,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html?is-external=true" title="class or interface in java.util.concurrent" class="externalLink">TimeUnit</a>&nbsp;unit)</span></div>
<div class="block">Acquires the lock if it is free within the given waiting time,
 or already held by the current thread.
 <p>
 If the lock is available, this method returns immediately with the value
 <code>true</code>. When the call is reentrant, it immediately returns
 <code>true</code> if the lock acquire limit is not exceeded. Otherwise,
 it returns <code>false</code> on the reentrant lock attempt if the acquire
 limit is exceeded. Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more
 information.
 <p>
 If the lock is not available then the current thread becomes disabled
 for thread scheduling purposes and lies dormant until the lock is
 acquired by the current thread or the specified waiting time elapses.
 <p>
 If the lock is acquired, then the value <code>true</code> is returned.
 <p>
 If the specified waiting time elapses, then the value <code>false</code>
 is returned. If the time is less than or equal to zero, the method does
 not wait at all.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#tryLock(long,java.util.concurrent.TimeUnit)" title="class or interface in java.util.concurrent.locks" class="externalLink">tryLock</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>time</code> - the maximum time to wait for the lock</dd>
<dd><code>unit</code> - the time unit of the <code>time</code> argument</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the lock was acquired and <code>false</code>
         if the waiting time elapsed before the lock was acquired</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="tryLockAndGetFence(long,java.util.concurrent.TimeUnit)">tryLockAndGetFence</a></h3>
<div class="memberSignature"><span class="returnType">long</span>&nbsp;<span class="memberName">tryLockAndGetFence</span>&#8203;(<span class="arguments">long&nbsp;time,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html?is-external=true" title="class or interface in java.util.concurrent" class="externalLink">TimeUnit</a>&nbsp;unit)</span></div>
<div class="block">Acquires the lock if it is free within the given waiting time,
 or already held by the current thread at the time of invocation &amp;
 the acquire limit is not exceeded, and returns the fencing token
 assigned to the current thread for this lock acquire. If the lock is
 acquired reentrantly, the same fencing token is returned. If the lock
 acquire limit is exceeded, then this method immediately returns
 <a href="#INVALID_FENCE"><code>INVALID_FENCE</code></a> that represents a failed lock attempt.
 Please see <a href="../../config/cp/FencedLockConfig.html" title="class in com.hazelcast.config.cp"><code>FencedLockConfig</code></a> for more information.
 <p>
 If the lock is not available then the current thread becomes disabled
 for thread scheduling purposes and lies dormant until the lock is
 acquired by the current thread or the specified waiting time elapses.
 <p>
 If the specified waiting time elapses, then <a href="#INVALID_FENCE"><code>INVALID_FENCE</code></a>
 is returned. If the time is less than or equal to zero, the method does
 not wait at all.
 <p>
 This is a convenience method for the following pattern:
 <pre>
     FencedLock lock = ...;
     if (lock.tryLock(time, unit)) {
         return lock.getFence();
     } else {
         return FencedLock.INVALID_FENCE;
     }
 </pre>
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
      FencedLock lock = ...; // the lock is free
      lock.tryLockAndGetFence(time, unit);
      // JVM of the caller thread hits a long pause and its CP session
      is closed on the CP group.
      lock.tryLockAndGetFence(time, unit);
 </pre>
 In this scenario, a thread acquires the lock, then its JVM instance
 encounters a long pause, which is longer than
 <a href="../../config/cp/CPSubsystemConfig.html#getSessionTimeToLiveSeconds()"><code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code></a>. In this case,
 its CP session will be closed on the corresponding CP group because
 it could not commit session heartbeats in the meantime. After the JVM
 instance wakes up again, the same thread attempts to acquire the lock
 reentrantly. In this case, the second lock() call fails by throwing
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> which extends
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>. If the caller wants to deal with
 its session loss by taking some custom actions, it can handle the thrown
 <a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception"><code>LockOwnershipLostException</code></a> instance. Otherwise, it can treat it
 as a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>IllegalMonitorStateException</code></a>.
 <p>
 Fencing tokens are monotonic numbers that are incremented each time
 the lock switches from the free state to the acquired state. They are
 simply used for ordering lock holders. A lock holder can pass
 its fencing to the shared resource to fence off previous lock holders.
 When this resource receives an operation, it can validate the fencing
 token in the operation.
 <p>
 Consider the following scenario where the lock is free initially:
 <pre>
     FencedLock lock = ...; // the lock is free
     long fence1 = lock.tryLockAndGetFence(time, unit); // (1)
     long fence2 = lock.tryLockAndGetFence(time, unit); // (2)
     assert fence1 == fence2;
     lock.unlock();
     lock.unlock();
     long fence3 = lock.tryLockAndGetFence(time, unit); // (3)
     assert fence3 &gt; fence1;
 </pre>
 In this scenario, the lock is acquired by a thread in the cluster. Then,
 the same thread reentrantly acquires the lock again. The fencing token
 returned from the second acquire is equal to the one returned from the
 first acquire, because of reentrancy. After the second acquire, the lock
 is released 2 times, hence becomes free. There is a third lock acquire
 here, which returns a new fencing token. Because this last lock acquire
 is not reentrant, its fencing token is guaranteed to be larger than the
 previous tokens, independent of the thread that has acquired the lock.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>time</code> - the maximum time to wait for the lock</dd>
<dd><code>unit</code> - the time unit of the <code>time</code> argument</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the fencing token if the lock was acquired and
         <a href="#INVALID_FENCE"><code>INVALID_FENCE</code></a> otherwise</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while locking reentrantly</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="unlock()">unlock</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">unlock</span>()</div>
<div class="block">Releases the lock if the lock is currently held by the current thread.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#unlock()" title="class or interface in java.util.concurrent.locks" class="externalLink">unlock</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalMonitorStateException</a></code> - if the lock is not held by
         the current thread</dd>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed before the current thread releases the lock</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getFence()">getFence</a></h3>
<div class="memberSignature"><span class="returnType">long</span>&nbsp;<span class="memberName">getFence</span>()</div>
<div class="block">Returns the fencing token if the lock is held by the current thread.
 <p>
 Fencing tokens are monotonic numbers that are incremented each time
 the lock switches from the free state to the acquired state. They are
 simply used for ordering lock holders. A lock holder can pass
 its fencing to the shared resource to fence off previous lock holders.
 When this resource receives an operation, it can validate the fencing
 token in the operation.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the fencing token if the lock is held by the current thread</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalMonitorStateException</a></code> - if the lock is not held by
         the current thread</dd>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while the current thread is holding the lock</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isLocked()">isLocked</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">isLocked</span>()</div>
<div class="block">Returns whether this lock is locked or not.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if this lock is locked by any thread
         in the cluster, <code>false</code> otherwise.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while the current thread is holding the lock</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isLockedByCurrentThread()">isLockedByCurrentThread</a></h3>
<div class="memberSignature"><span class="returnType">boolean</span>&nbsp;<span class="memberName">isLockedByCurrentThread</span>()</div>
<div class="block">Returns whether the lock is held by the current thread or not.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the lock is held by the current thread or not,
         <code>false</code> otherwise.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while the current thread is holding the lock</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getLockCount()">getLockCount</a></h3>
<div class="memberSignature"><span class="returnType">int</span>&nbsp;<span class="memberName">getLockCount</span>()</div>
<div class="block">Returns the reentrant lock count if the lock is held by any thread
 in the cluster.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the reentrant lock count if the lock is held by any thread
         in the cluster</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="exception/LockOwnershipLostException.html" title="class in com.hazelcast.cp.lock.exception">LockOwnershipLostException</a></code> - if the underlying CP session is
         closed while the current thread is holding the lock</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getGroupId()">getGroupId</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../CPGroupId.html" title="interface in com.hazelcast.cp">CPGroupId</a></span>&nbsp;<span class="memberName">getGroupId</span>()</div>
<div class="block">Returns id of the CP group that runs this <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>id of the CP group that runs this <a href="FencedLock.html" title="interface in com.hazelcast.cp.lock"><code>FencedLock</code></a> instance</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="newCondition()">newCondition</a></h3>
<div class="memberSignature"><span class="returnType"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Condition</a></span>&nbsp;<span class="memberName">newCondition</span>()</div>
<div class="block">NOT IMPLEMENTED. Fails by throwing <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>UnsupportedOperationException</code></a>.
 <p>
 May the force be the one who dares to implement
 a linearizable distributed <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink"><code>Condition</code></a> :)</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true#newCondition()" title="class or interface in java.util.concurrent.locks" class="externalLink">newCondition</a></code>&nbsp;in interface&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html?is-external=true" title="class or interface in java.util.concurrent.locks" class="externalLink">Lock</a></code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true" title="class or interface in java.lang" class="externalLink">UnsupportedOperationException</a></code> - for now</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/FencedLock.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2021 <a href="http://www.hazelcast.com/">Hazelcast, Inc.</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
